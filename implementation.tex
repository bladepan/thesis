\section{Design and Implementation}
\label{sec:implementation}
As shown in Figure~\ref{fig:cb2arch}, 
a \cb{} system consists of one master node and multiple worker nodes.
These nodes are separated processes and they communicate with each other
with HTTP messages.
So \cb{} could be flexibly deployed  
to one one machine or multiple machines 
as long as they can reach each other by network.

The worker nodes correspond to the web layer in Fig.~\ref{fig:webscaleout},
they execute actual application code and process user requests.
The master distributes client requests to workers and relays the 
response from workers to clients.



% FIXME merge into the master chapter
If the user requests an Application URL or an \appins{} URL, 
\cb{} will try to allocate a virtual browser for the request,
after that, the system will send a redirect response containing a Browser URL to the user.
When the user requests a Browser URL,
the system will dispatch the request to the worker node hosts the corresponding virtual browser,
the user will receive a bootstrap HTML document containing links to client engine code just as
the original design.
After the client engine is initialized, the client engine will send requests
to master node to establish web socket connection.
All the client server communication afterwards is transmitted via web socket.
In the bootstrap HTML document, 
the server will also write the virtual browser's id and the virtual browser's 
\appins{} id in \js{} code,
the client engine will embed these ids into the URL when establishing web socket
connection.
%The client engine is fully aware of the current \appins{} id and virtual browser id, 
%all the HTTP requests initiated by the client engine will attach those ids in the URL.



\newarchitectureoverview{}

\subsection{Client Bootstrap}
Like in any other web framework, 
the hosted web applications are exposed to the clients via URLs.
\cb{} hides a distributed system from the user transparently,
the user only needs to know the master's DNS name or IP address to 
access a web application.
In the following of the paper, 
we assume the master's DNS name is \emph{example.com}.
A user could use any of the below URL types to access an application in \cb{}.
\begin{enumerate}
\item \label{itm:appurl} http://example.com/[app] : Application URL.
`app' is an application specified mount point. 
For example, a chat application's mount point URL could be http://example.com/chat.
\item \label{itm:appinsurl} http://example.com/[app]/a/[appInstanceId] : \appins{} URL.
`appInstanceId' is id of a \appins{}. For example,
\appins{} 1 in chat application has the URL http://example.com/chat/a/1.
access \appins{} 1 in chat application.
\item \label{itm:vburl} http://example.com/[app]/a/[appInstanceId]/b/[browserId] : Browser URL.
`browserId' is id of a virtual browser. For example, virtual browser 2 is inside \appins{} 1 of
chat application, so that virtual browser's URL is http://example.com/chat/a/1/b/2.
\end{enumerate}
\appins{} is a container of virtual browsers.
In our new design,
a virtual browser must be created inside an \appins{},
an \appins{} can have multiple virtual browsers.
We will discuss \appins{} in detail in the remainder of this paper.

When the system receives a new request from client,
it will allocate a new or existing virtual browser for the request .
If the request URL is not a \emph{Browser URL}, 
the system will send back a HTTP 302 redirect response 
with a \emph{Browser URL} to the client.
The client will send a new request with the \emph{Browser URL} 
after receiving the redirect response.
If the request URL is a \emph{Browser URL},
the master will forward the request to the worker 
that contains the corresponding \appins{} and virtual browser.
Then the worker will send back a initial HTML document.
The initial HTML document contains in-line \js{} code that 
encodes the \appins{} id and virtual browser id,
links to Client Engine code,
and a few HTML elements like head and body.
After loading the initial HTML document, 
the user's browser will load and execute the Client Engine code.
The Client Engine will establish a web socket connection with the master,
the master will tunnel this connection to the corresponding worker node
because the Client Engine will embed the \appins{} id in the request URL.
After that, the master node will just copy messages running in the 
connection back and forth.
Like in previous design, 
the Client Engine receives DOM updates and forwards client events via
web socket connection.
For clarity, 
we omit the cases that the system rejects client requests
due to various possible exceptions like  illegal URL,
authorization exception, etc.

\subsection{Master}
Figure~\ref{fig:dispatch} presents the dispatch logic of the master node.
When the master receives a new request from client,
it first tries to extract \appins{} id from the request URL.
If the request URL contains an \appins{},
the master will look up a in-memory mapping table to find the worker
that hosts the \appins{} and forward the request to it.
If this request URL does not contain an \appins{},
the master would pick a worker node using load balancing mechanism in section~\ref{sec:lb}.
% In this case, the worker node would use application specific logic to handle this request.
% For example, 
% a single page application could be configured allocate only one virtual browser for 
% a user.
% In this case, 
% the worker node will try to find an existing virtual browser for that user or 
% create a new one if it cannot find an existing one.
% Then the worker sends a redirect response with the virtual browser's URL
% to the client.



It is noticeable that the majority of the client server traffic are
web socket messages (user interface update and event forwarding),
those messages are transmitted via an established web socket that is already tunneled to 
a worker node.
The master do not need to interfere with these messages.
So dispatch logic is only executed in the client bootstrap process.

% one way, two way forwarding
For simplicity, all the client traffic and the workers' responses goes through master node.
We use an open source \nodejs{} module node HTTP proxy~\cite{nodeproxy} to implement
an embedded HTTP proxy inside master node.
The embedded HTTP proxy listens on the port that clients connect to,
when the proxy receives a HTTP request,
it will call the dispatch method to get a worker node and then relay the message
to the worker node.
We also considered to use high performance HTTP reverse proxy nginx~\cite{nginx}
to relay requests,
but to do so we need to modify nginx's source code to 
make it talks to master node before relaying requests,
also it would make the deployment of \cb{} more complex.
On the other hand, the embedded HTTP proxy could directly invoke master's methods.
However, as the embedded HTTP proxy runs on the same thread as the master's other
components, the master could be overwhelmed under heavy load.
This could be alleviated by using \nodejs{}'s Cluster API to make the embedded HTTP
proxy to run on multiple processes.

\requestdispatchdiagram{}

\subsubsection{Load Balancing}
\label{sec:lb}
To make the work load as evenly distributed to the worker nodes as possible,
the master node assign a integer weight value to each worker
and the worker with the smallest weight will be picked to handle new requests
or create new \appins{}.
To make the weight value reflect the actual load of the worker,
the worker node sends heartbeat message containing 
its heapUsed value to master every 3 seconds(
the heapUsed value is the total size of \js{} objects that have not been
reclaimed by garbage collector, 
it is a more accurate indicator of the worker's load than resident memory size
).
The master stores the heapUsed in megabytes as the worker's weight.
To avoid a burst of workload all being directed to a fixed worker.
Every time the master node forward requests or send create \appins{} command to a worker,
the weight value of that node will be incremented by an empirical amount.
For example, if there are two workers w1 and w2 in the system with weight
100 and 101 respectively.
Before the next heartbeat message from w1 arrives the master received ten requests to 
create \appins{}.
If we do not increase the worker's weight after forwarding a request,
we end up let w1 handles all the work.
If we increase the worker's weight by 10 for each \appins{} created,
we will distribute these ten requests evenly between these 2 workers.
Even if the number we add to the weight does not accurately amount to the actual 
heapUsed of the worker, it will be fixed after receiving the next heart beat message.

\subsection{Worker}
\label{sec:worker}
The worker node handles the client requests forwarded by the master node,
When worker node receives a client request forwarded by the master,
one of the following could happen:
\begin{enumerate}
    \item The request URL is a \emph{Browser URL}.
     The worker finds the virtual browser specified in the URL, sends back a initial HTML document.
    \item The request URL is an \emph{\appins{} URL}.
        The worker first finds the \appins{} specified in the URL, 
        then use an existing virtual browser or create a new one inside that \appins{} for the client, 
        then the worker sends back a redirect response with the virtual browser's URL.
    \item The request is an \emph{Application URL}. 
    The worker will either allocate an \appins{} and virtual browser locally 
    or ask the master node to find an \appins{} and virtual browser 
    in the system for this request.
    After that the worker will send back a redirect response with the
    virtual browser's URL.
\end{enumerate}
In the latter two cases,
whether the system should create a new \appins{} or a new virtual browser 
for the request is determined by application specified rules.
For example, 
a single page application might restrict each user has only one view.
This could be achieved by configure the application as a `singleUserInstance' 
application.
That is the framework will make sure only one \appins{} with one virtual browser
will be created for each user.
For this application, if the user does not specify a virtual browser id
in his request,
the worker needs to check if any virtual browser has been created for this user
in the system.
If the request URL is an \emph{\appins{} URL},
the worker needs only to check if the specified \appins{} is created for the user
and if there is any virtual browser in the \appins{}.
If the request URL is an \emph{Application URL},
the worker needs to ask the master to find an \appins{} in the system
if there is no \appins{} for the user locally.
The reason why the master is involved is because
the the master maintains 
a map of \appins{} to worker nodes so it is capable of answer this question.
Also, when there is no existing \appins{} for the user in the system,
the master could find a most free worker using the load balancing algorithm mentioned
earlier to create a new \appins{} and virtual browser for the user.

We have omit the cases that the worker could also deny the request.
For example, 
the client does not have the authorization to access the virtual browser or \appins{} specified
in request URL.

For web socket messages, 
before the connection established,
the worker node will first check for the validity of the attached
 \appins{} id and virtual browser id in request header,
then the worker node will check if the user has the authorization to access
the specified virtual browser.
The connection will be closed if any of the checking fails.
After the web socket connection establishes,
the worker node will send the current DOM elements of the virtual browser 
to the connection.
Then the client engine could construct user interface based on the DOM elements received.

\appinstancefig{}

\subsection{\appins{}}
\label{sec:appins}
\appins{} is designed to help developers to maintain 
the application state that is shared by multiple views.
Developers can create multiple virtual browsers inside
an \appins{}.
When a virtual browser is created,
the system inject an API object as a global variable 
in the virtual browser's \emph{window}.
The application code can get reference to server side
object like database connection via this API object.
The \appins{} is also exposed to application code by the API objects.
For example, in a chat room application,
each user has his distinct view of a chat room.
As in Figure~\ref{fig:appinstance}, 
each user's view of a chat room is maintained by a virtual browser.
These views share a chat room object that maintains the chat messages
in the chat room.
With \appins{}, we can create an \appins{} for each chat room
and attach the chat room object in the \appins{}.
Then for each user who joins the chat room we create a virtual browser
under the \appins{}.
The application code could directly manipulate the chat room object
like append a new message to \emph{messages},
other virtual browsers in the \appins{} can see the change immediately.

Combined with the routing mechanism,
\appins{} allows multiple views to share data without the help
of back-end services like event queue, cache, database, etc.
And using local object referencing is much faster than those alternatives.


% %FIXME
% On top of virtual browser, 
% \cb{} has a level of abstraction called \appins{} that is helpful
% to build collaborative applications.
% An \appins{} is a group of virtual browsers that are guaranteed to be placed
% in the same \cb{} process.
% The virtual browsers from the same \appins{} share a user defined \appins{} object.
% The developer could use a \appins{} object to describe an entity that 
% could be accessed by multiple users, 
% then create virtual browser under that \appins{} as user's views of this shared entity.
% For example, the application could use an \appins{} object as a shared document and 
% define various properties and methods on that object.
% Whenever a user want to edit that document, the application
% creates a virtual browser under that \appins{},
% the user specific application state like user name and editor settings 
% could be stored in variables inside his virtual browser.
% The application could use the \appins{} object directly to render the document for every user, 
% and each user can have his own view of the editor.

% MARK
\subsection{Remote Method Invocation}
In \cb{} programming API and some internal module, there are use cases like list all the App Instances in an application
and terminate a virtual browser.
In the single process version, these operations would be accomplished by simple local method invocation
since all the objects are in the same process.
For multiple processes,
we need substitute direct method invocation with message communication between processes.
In the meantime, we want to preserve the code structure as much as possible,
and we do not want to do a huge code refactor each time we decide to access some more types of objects remotely.


To solve this problem,
we developed a Node.js library nodermi~\cite{nodermi} to handle the complexity of accessing a remote object.
We will use the term \emph{client} referring to the process that needs to access a remote object,
the term \emph{server} referring to the process that provides that object.
The client access the remote object's properties or methods through a stub object generated by nodermi.
The stub object cashes all the remote object's properties,
so for the property access there is no message communication involved.
For methods,
the stub object will send method invocation message to server and handle response or error under the hood.
All objects returned~\footnote{Here 'return' does not mean using return keyword, it means using a callback function to pass back the result.} by remote method invocation
 except simple type objects like string or date are serialized in the server side
 and reincarnated as a stub object in the client side.

% https://Node.jsmodules.org/tags/rmi
There are some existing rmi libraries for Node.js.
To our best knowledge, none of which could satisfy all the use cases we need.
Nodermi is capable of handling some complex use cases involving multiple servers and clients.
Consider the following use case:
Server A has an object A,
Server B has a method called listAllObjects that would return an array contains object A,
Server C calls Server B's listAllObjects method and get a reference of object A,
then C invokes object A's method method1.
Nodermi is able to recognize object A is from server A and server C will talk to server A directly.
However other rmi libraries fails to do such optimization.
Besides, we could specify properties to omit during serialization using nodermi,
this could significantly reduce the message size in our system.

\subsection{Synchronous Vs. Asynchronous}
Due to the single thread nature of Node.js,
it is critical that remote method invocations do not block the main thread.
So the underlying IO operations for RMI need to be performed asynchronously.
Consequently, the result of an RMI could only be read asynchronously.
If the caller code need a RMI to return a result,
the only way is get the result through a callback function
after it is read from a remote server.
Conventionally in Node.js, an asynchronous executed method
accept a callback function as its last parameter.
Nodermi takes advantage of this knowledge and handle methods with callback parameter transparently
~\footnote{A method with a callback parameter is not necessarily a asynchronous method,
but for the caller there is no difference if the method execute the callback synchronously or asynchronously}.
But for a method that is originally use return keyword to the caller,
we need to change its signature to add a callback function as a parameter and
replace the return statement with a call to the callback. % TODO add a fig for this
We also have to refactor the code of the corresponding RMI to use callback instead of
directly assignment.



\begin{listing}[ht,width=0.3\textwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
var a = someService.getSomeObject1(key);

someService.getSomeObject2(a,
    function(err, result){
        //do something with result
    }
);
\end{minted}
\caption{Code sample from single process \cb{}}
\label{code:single}
\end{listing}

\begin{listing}[ht,width=0.3\textwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
// getSomeObject1 is refactored
// to use a callback
someService.getSomeObject1(key,
    function(err, a){
        if(err){
            throw err;
        }
        // getSomeObject2's signature
        // could remain the same
        someService.getSomeObject2(a,
            function(err, result){
                //do something with result
            }
        );
    }
);
\end{minted}
\caption{Code sample from multiple process \cb{}}
\label{code:multi}
\end{listing}
