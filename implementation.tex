\section{Design and Implementation}
\label{sec:implementation}
%In designing the new \cb{}, 
%we also explore solutions for developers to store session data.
One challenge to expand a web application to multiple processes is 
how to store session data.
For a single server web application, 
the session data could be stored in memory.
For multiple servers,
application frameworks like J2EE~\cite{j2eedoc} suggest use persistent
storage like database for session data.
If the session data volume is huge or the access rate is frequent,
reading session data from database could be a performance bottleneck.
Caching session data locally on each server sounds like a good solution,
but it has a warm up latency as a server needs to load session data when 
the session data is generated elsewhere
and it needs some sort of coherence mechanism to dealing with session data updates.
Some methods~\cite{shachor2005maintaining} are devised to create session affinity
to application servers so session data look up could be processed in memory.
For \cb{}, 
each request is associated with a virtual browser,
session affinity is naturally maintained by the framework,
developers could still create plain \js{} objects in the application code to 
store session data.




To distribute a web application among multiple processes, 
a simple approach would be dispatch the user's requests to server processes randomly or in a round robin fashion.
This approach is not feasible for \cb{} because 
the client needs to synchronize with a particular virtual browser.
So a dispatch mechanism is required to direct the client requests to the right process.
Another issue arises in distributing virtual browsers among processes is 
how the virtual browsers access shared data.
We could store all shared data in database and let application code call database APIs to get these data.
This approach is already supported by \cb{} and makes sense for data that needs to be persisted like user profiles. 
We also provide a mechanism called App Instance to group multiple virtual browsers,
the virtual browsers in the same App Instance are guaranteed to locate in the same process and they could
share in-memory data structure directly to each other through App Instance object.
Applications like chat room could benefit from using App Instance to boost performance :
application could initiate an App Instance for each chat room to broadcast chat messages, 
whenever a virtual browser posts a new chat message all other browsers get the update.



%We also provide a in-memory data sharing mechanism called App Instance for use cases that need better performance than database.
%User could define 
%For the shared data that does not need to be persisted, 
%But for some temporary data, this could be expensive 

As shown in Figure~\ref{fig:cb2arch}, the server side is divided into one master node and multiple worker nodes.
The master node acts as a proxy which dispatches requests from user to worker nodes.
The worker node hosts virtual browsers which execute application code.
Like in the original design, 

\newarchitectureoverview{}
\requestdispatchdiagram{}
\appinstancefig{}

% some graphs

\subsection{Master}
The master node stores a map of App Instances to worker nodes.
When the user sends a request, 
the master node checks if the request could be dispatched to an existing App Instance,
if it could the master forward the request to the worker node hosts that App Instance, 
otherwise it would either command a worker to initialize an App Instance and forward the
request to the worker, or reject the request.
The logic of whether to reject a request and how to initiate an App Instance is defined by the application writer.
The request forward process is essentially a reverse proxy server.

\subsection{Worker}
The worker node runs actual virtual browser instances.
Upon start up the worker node fetches application configurations from master node.
Whenever the worker node initiate an App Instance, it will register the App Instance with master node.
The worker node directs the incoming requests to corresponding virtual browsers.
The processing of the requests is the same as the original \cb{}.
The difference is that the response is passed to master instead of write directly to client.


\subsection{Remote Method Invocation}
In \cb{} programming API and some internal module, there are use cases like list all the App Instances in an application 
and terminate a virtual browser.
In the single process version, these operations would be accomplished by simple local method invocation 
since all the objects are in the same process.
For multiple processes, 
we need substitute direct method invocation with message communication between processes.
In the meantime, we want to preserve the code structure as much as possible, 
and we do not want to do a huge code refactor each time we decide to access some more types of objects remotely.


To solve this problem, 
we developed a Node.js library nodermi~\cite{nodermi} to handle the complexity of accessing a remote object.
We will use the term \emph{client} referring to the process that needs to access a remote object, 
the term \emph{server} referring to the process that provides that object.
The client access the remote object's properties or methods through a stub object generated by nodermi.
The stub object cashes all the remote object's properties, 
so for the property access there is no message communication involved.
For methods,
the stub object will send method invocation message to server and handle response or error under the hood.
All objects returned~\footnote{Here 'return' does not mean using return keyword, it means using a callback function to pass back the result.} by remote method invocation
 except simple type objects like string or date are serialized in the server side
 and reincarnated as a stub object in the client side.

% https://Node.jsmodules.org/tags/rmi
There are some existing rmi libraries for Node.js. 
To our best knowledge, none of which could satisfy all the use cases we need.
Nodermi is capable of handling some complex use cases involving multiple servers and clients.
Consider the following use case:
Server A has an object A, 
Server B has a method called listAllObjects that would return an array contains object A,
Server C calls Server B's listAllObjects method and get a reference of object A,
then C invokes object A's method method1.
Nodermi is able to recognize object A is from server A and server C will talk to server A directly.
However other rmi libraries fails to do such optimization.
Besides, we could specify properties to omit during serialization using nodermi, 
this could significantly reduce the message size in our system.

\subsection{Synchronous Vs. Asynchronous}
Due to the single thread nature of Node.js, 
it is critical that remote method invocations do not block the main thread.
So the underlying IO operations for RMI need to be performed asynchronously.
Consequently, the result of an RMI could only be read asynchronously.
If the caller code need a RMI to return a result,
the only way is get the result through a callback function 
after it is read from a remote server.
Conventionally in Node.js, an asynchronous executed method 
accept a callback function as its last parameter.
Nodermi takes advantage of this knowledge and handle methods with callback parameter transparently
~\footnote{A method with a callback parameter is not necessarily a asynchronous method, 
but for the caller there is no difference if the method execute the callback synchronously or asynchronously}.
But for a method that is originally use return keyword to the caller, 
we need to change its signature to add a callback function as a parameter and 
replace the return statement with a call to the callback. % TODO add a fig for this
We also have to refactor the code of the corresponding RMI to use callback instead of 
directly assignment.



\begin{listing}[ht,width=0.3\textwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
var a = someService.getSomeObject1(key);

someService.getSomeObject2(a, 
    function(err, result){
        //do something with result
    }
);
\end{minted}
\caption{Code sample from single process \cb{}}
\label{code:single}
\end{listing}

\begin{listing}[ht,width=0.3\textwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
// getSomeObject1 is refactored 
// to use a callback
someService.getSomeObject1(key, 
    function(err, a){
        if(err){
            throw err;
        }
        // getSomeObject2's signature 
        // could remain the same
        someService.getSomeObject2(a, 
            function(err, result){
                //do something with result
            }
        );
    }
);
\end{minted}
\caption{Code sample from multiple process \cb{}}
\label{code:multi}
\end{listing}
