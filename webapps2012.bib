@article{Scheifler1986X,
    abstract = {{An overview of the X Window System is presented, focusing on the system substrate and the low-level facilities provided to build applications and to manage the desktop. The system provides high-performance, high-level, device-independent graphics. A hierarchy of resizable, overlapping windows allows a wide variety of application and user interfaces to be built easily. Network-transparent access to the display provides an important degree of functional separation, without significantly affecting performance, which is crucial to building applications for a distributed environment. To a reasonable extent, desktop management can be custom-tailored to individual environments, without modifying the base system and typically without affecting applications.}},
    address = {New York, NY, USA},
    author = {Scheifler, Robert W. and Gettys, Jim},
    citeulike-article-id = {991725},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=24053},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/22949.24053},
    doi = {10.1145/22949.24053},
    issn = {0730-0301},
    journal = {ACM Trans. Graph.},
    month = apr,
    number = {2},
    pages = {79--109},
    posted-at = {2012-04-14 05:05:33},
    priority = {2},
    publisher = {ACM},
    title = {{The X window system}},
    url = {http://dx.doi.org/10.1145/22949.24053},
    volume = {5},
    year = {1986}
}

@article{Kotzmann2008Design,
    abstract = {{Version 6 of Sun Microsystems' Java HotSpot™ VM ships with a redesigned version of the client just-in-time compiler that includes several research results of the last years. The client compiler is at the heart of the VM configuration used by default for interactive desktop applications. For such applications, low startup and pause times are more important than peak performance. This paper outlines the new architecture of the client compiler and shows how it interacts with the VM. It presents the intermediate representation that now uses static single-assignment (SSA) form and the linear scan algorithm for global register allocation. Efficient support for exception handling and deoptimization fulfills the demands that are imposed by the dynamic features of the Java programming language. The evaluation shows that the new client compiler generates better code in less time. The popular SPECjvm98 benchmark suite is executed 45\&percnt; faster, while the compilation speed is also up to 40\&percnt; better. This indicates that a carefully selected set of global optimizations can also be integrated in just-in-time compilers that focus on compilation speed and not on peak performance. In addition, the paper presents the impact of several optimizations on execution and compilation speed. As the source code is freely available, the Java HotSpot™ VM and the client compiler are the ideal basis for experiments with new feedback-directed optimizations in a production-level Java just-in-time compiler. The paper outlines research projects that add fast algorithms for escape analysis, automatic object inlining, and array bounds check elimination.}},
    address = {New York, NY, USA},
    author = {Kotzmann, Thomas and Wimmer, Christian and M\"{o}ssenb\"{o}ck, Hanspeter and Rodriguez, Thomas and Russell, Kenneth and Cox, David},
    citeulike-article-id = {2853135},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1369396.1370017},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1369396.1370017},
    day = {01},
    doi = {10.1145/1369396.1370017},
    issn = {1544-3566},
    journal = {ACM Trans. Archit. Code Optim.},
    month = may,
    number = {1},
    pages = {1--32},
    posted-at = {2012-04-14 03:33:57},
    priority = {2},
    publisher = {ACM},
    title = {{Design of the Java HotSpot\&trade; client compiler for Java 6}},
    url = {http://dx.doi.org/10.1145/1369396.1370017},
    volume = {5},
    year = {2008}
}

@article{Czajkowski2001Multitasking,
    abstract = {{The multitasking virtual machine (called from now on simply MVM) is a modification of the Java virtual machine. It enables safe, secure, and scalable multitasking. Safety is achieved by strict isolation of application from one another. Resource control augment security by preventing some denial-of-service attacks. Improved scalability results from an aggressive application of the main design principle of MVM: share as much of the runtime as possible among applications and replicate everything else. The system can be described as a 'no compromise'approach --- all the known APIs and mechanisms of the Java programming language are available to applications. MVM is implemented as a series of carefully tuned modifications to the Java HotSpot virtual machine, including the dynamic compiler. this paper presents the design of MVM, focusing on several novel and general techniques: an in-runtime design of lightweight isolation, an extension of a copying, generational garbage collector to provide best-effort management of a portion of the heap space, and a transparent and automated mechanism for safe execution of user-level native code. MVM demonstrates that multitasking in a safe language can be accomplished with a high degree of protection, without constraining the language, and and with competitive performance characteristics}},
    address = {New York, NY, USA},
    author = {Czajkowski, Grzegorz and Dayn{\'{e}}s, Laurent},
    citeulike-article-id = {8855785},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=504282.504292},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/504311.504292},
    doi = {10.1145/504311.504292},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    month = oct,
    number = {11},
    pages = {125--138},
    posted-at = {2012-04-14 03:32:14},
    priority = {2},
    publisher = {ACM},
    title = {{Multitasking without comprimise: a virtual machine evolution}},
    url = {http://dx.doi.org/10.1145/504311.504292},
    volume = {36},
    year = {2001}
}

@inproceedings{Deutsch1984Efficient,
    abstract = {{The Smalltalk-80* programming language includes dynamic storage allocation, full upward funargs, and universally polymorphic procedures; the Smalltalk-80 programming system features interactive execution with incremental compilation, and implementation portability. These features of modern programming systems are among the most difficult to implement efficiently, even individually. A new implementation of the Smalltalk-80 system, hosted on a small microprocessor-based computer, achieves high performance while retaining complete (object code) compatibility with existing implementations. This paper discusses the most significant optimization techniques developed over the course of the project, many of which are applicable to other languages. The key idea is to represent certain runtime state (both code and data) in more than one form, and to convert between forms when needed.}},
    address = {New York, NY, USA},
    author = {Deutsch, L. Peter and Schiffman, Allan M.},
    booktitle = {Proceedings of the 11th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
    citeulike-article-id = {112856},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=800542},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/800017.800542},
    doi = {10.1145/800017.800542},
    isbn = {0-89791-125-3},
    location = {Salt Lake City, Utah, United States},
    pages = {297--302},
    posted-at = {2012-04-14 03:29:18},
    priority = {2},
    publisher = {ACM},
    series = {POPL '84},
    title = {{Efficient implementation of the smalltalk-80 system}},
    url = {http://dx.doi.org/10.1145/800017.800542},
    year = {1984}
}

@article{Reese2008Nginx,
    abstract = {{A leaner, meaner Apache.}},
    address = {Houston, TX},
    author = {Reese, Will},
    citeulike-article-id = {10563605},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1412202.1412204},
    issn = {1075-3583},
    journal = {Linux J.},
    month = sep,
    number = {173},
    posted-at = {2012-04-14 02:23:06},
    priority = {2},
    publisher = {Belltown Media},
    title = {{Nginx: the high-performance web server and reverse proxy}},
    url = {http://portal.acm.org/citation.cfm?id=1412202.1412204},
    volume = {2008},
    year = {2008}
}

@article{Pariag2007Comparing,
    abstract = {{In this paper, we extensively tune and then compare the performance of web servers based on three different server architectures. The μserver utilizes an event-driven architecture, Knot uses the highly-efficient Capriccio thread library to implement a thread-per-connection model, and WatPipe uses a hybrid of events and threads to implement a pipeline-based server that is similar in spirit to a staged event-driven architecture (SEDA) server like Haboob. We describe modifications made to the Capriccio thread library to use Linux's zero-copy sendfile interface. We then introduce the SY mmetric Multi-Processor Event Driven (SYMPED) architecture in which relatively minor modifications are made to a single process event-driven (SPED) server (the μserver) to allow it to continue processing requests in the presence of blocking due to disk accesses. Finally, we describe our C++ implementation of WatPipe, which although utilizing a pipeline-based architecture, excludes the dynamic controls over event queues and thread pools used in SEDA. When comparing the performance of these three server architectures on the workload used in our study, we arrive at different conclusions than previous studies. In spite of recent improvements to threading libraries and our further improvements to Capriccio and Knot, both the event-based μserver and pipeline-based Wat-Pipe server provide better throughput (by about 18\%). We also observe that when using blocking sockets to send data to clients, the performance obtained with some architectures is quite good and in one case is noticeably better than when using non-blocking sockets.}},
    address = {New York, NY, USA},
    author = {Pariag, David and Brecht, Tim and Harji, Ashif and Buhr, Peter and Shukla, Amol and Cheriton, David R.},
    citeulike-article-id = {3718633},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1272998.1273021},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1272998.1273021},
    doi = {10.1145/1272998.1273021},
    issn = {0163-5980},
    journal = {SIGOPS Oper. Syst. Rev.},
    month = mar,
    number = {3},
    pages = {231--243},
    posted-at = {2012-04-14 02:22:19},
    priority = {2},
    publisher = {ACM},
    title = {{Comparing the performance of web server architectures}},
    url = {http://dx.doi.org/10.1145/1272998.1273021},
    volume = {41},
    year = {2007}
}

@inproceedings{Welsh2001SEDA,
    abstract = {{We propose a new design for highly concurrent Internet services, which we call the staged event-driven architecture (SEDA). SEDA is intended to support massive concurrency demands and simplify the construction of well-conditioned services. In SEDA, applications consist of a network of event-driven stages connected by explicit queues. This architecture allows services to be well-conditioned to load, preventing resources from being overcommitted when demand exceeds service capacity. SEDA makes use of a set of dynamic resource controllers to keep stages within their operating regime despite large fluctuations in load. We describe several control mechanisms for automatic tuning and load conditioning, including thread pool sizing, event batching, and adaptive load shedding. We present the SEDA design and an implementation of an Internet services platform based on this architecture. We evaluate the use of SEDA through two applications: a high-performance HTTP server and a packet router for the Gnutella peer-to-peer file sharing network. These results show that SEDA applications exhibit higher performance than traditional service designs, and are robust to huge variations in load.}},
    address = {New York, NY, USA},
    author = {Welsh, Matt and Culler, David and Brewer, Eric},
    booktitle = {Proceedings of the eighteenth ACM symposium on Operating systems principles},
    citeulike-article-id = {208330},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=502057},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/502034.502057},
    doi = {10.1145/502034.502057},
    isbn = {1-58113-389-8},
    issn = {0163-5980},
    journal = {SIGOPS Oper. Syst. Rev.},
    location = {Banff, Alberta, Canada},
    month = dec,
    number = {5},
    pages = {230--243},
    posted-at = {2012-04-14 02:17:18},
    priority = {2},
    publisher = {ACM},
    series = {SOSP '01},
    title = {{SEDA: an architecture for well-conditioned, scalable internet services}},
    url = {http://dx.doi.org/10.1145/502034.502057},
    volume = {35},
    year = {2001}
}

@inproceedings{Miller1968Response,
    abstract = {{The literature concerning man-computer transactions abounds in controversy about the limits of "system response time" to a user's command or inquiry at a terminal. Two major semantic issues prohibit resolving this controversy. One issue centers around the question of "Response time to what?" The implication is that different human purposes and actions will have different acceptable or useful response times.}},
    address = {New York, NY, USA},
    author = {Miller, Robert B.},
    booktitle = {Proceedings of the December 9-11, 1968, fall joint computer conference, part I},
    citeulike-article-id = {10562779},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1476628},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1476589.1476628},
    doi = {10.1145/1476589.1476628},
    location = {San Francisco, California},
    pages = {267--277},
    posted-at = {2012-04-13 20:04:14},
    priority = {2},
    publisher = {ACM},
    series = {AFIPS '68 (Fall, part I)},
    title = {{Response time in man-computer conversational transactions}},
    url = {http://dx.doi.org/10.1145/1476589.1476628},
    year = {1968}
}

@article{Edwards2011Bringing,
    abstract = {{Improving recruitment and retention depends on linking activities to real-world contexts that illustrate the social and societal impact of computer science. The sleek interaction and underlying technologies that define Web 2.0 applications offer a unique opportunity to teach CS concepts in a real-world context. Learn how students can create engaging Web 2.0 applications using simple Java programming and basic XHTML, without learning JavaScript or AJAX. See a full set of CS1 assignments leveraging this strategy. See how students can write a personal "Facebook-lite" they can show to friends. Play with live demos yourself. Leave with new assignment ideas.}},
    address = {USA},
    author = {Edwards, Stephen H. and Back, Godmar},
    citeulike-article-id = {7839922},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1859159.1859171},
    issn = {1937-4771},
    journal = {J. Comput. Sci. Coll.},
    month = jan,
    number = {3},
    pages = {54--55},
    posted-at = {2012-04-13 16:59:53},
    priority = {2},
    publisher = {Consortium for Computing Sciences in Colleges},
    title = {{Bringing creative web 2.0 programming into CS1: conference workshop}},
    url = {http://portal.acm.org/citation.cfm?id=1859159.1859171},
    volume = {26},
    year = {2011}
}

@inproceedings{Fernandes2011Strict,
    abstract = {{Despite many evolutions in the software architecture of enterprise applications, one thing has remained the same over the years: They still use a relational database both for data persistence and transactional support. We argue that such design, once justified by hardware limitations, endured mostly for legacy reasons and is no longer adequate for a significant portion of modern applications running in a new generation of multicore machines with very large memories. We propose a new architecture for enterprise applications that uses a Software Transactional Memory for transactional support at the application server tier, thereby shifting the responsibility of transaction control from the database to the application server. The database tier remains in our architecture with the sole purpose of ensuring the durability of data. With this change we are able to provide strictly serializable transaction semantics, and we do so with increased performance. Thus, we claim that strict serializability is harmless, in the sense that programmers no longer have to trade correctness for performance for a significant class of applications. We have been using this new architecture since 2005 in the development of real-world complex object-oriented applications, and we present statistical data collected over several years about the workload patterns of these applications, revealing a surprisingly low rate of write transactions.}},
    address = {New York, NY, USA},
    author = {Fernandes, S{\'{e}}rgio M. and Cachopo, Jo {.}},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10562088},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048221},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048221},
    doi = {10.1145/2048147.2048221},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {257--276},
    posted-at = {2012-04-13 15:08:56},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{Strict serializability is harmless: a new architecture for enterprise applications}},
    url = {http://dx.doi.org/10.1145/2048147.2048221},
    year = {2011}
}

@inproceedings{Basman2011To,
    abstract = {{Using current software development techniques, code and designs are often unmaintainable from the point of inception. Code is brittle and hard to refactor, hard to press to new purposes, and hard to understand. Here we present a system aimed at creating a model for scalable development, addressing this and several other critical problems in software construction. Such an aim is far from new, and has resembled the aims of each generation of software methodologists over the last 50 years. It deserves comment why these aims have so signally failed to be achieved, and we will present arguments as to why the combination of techniques explained here could expect to lead to novel results. Software products of today are notoriously unadaptable. An application which meets need A generally cannot be extended to meet apparently very similar need A' without something resembling "software engineering". Applications present users with a "take it or leave it" proposition - if the software doesn't happen to meet a user's needs or preferences, there's no way to change it without writing more code, which is out of reach for most users. Indeed, software regularly fails to be easily adaptable to meet the needs of users with differing needs, such as in the case of accessibility. These "precarious values" - accessibility and usability with different devices, languages, and personal needs - are typically left until the end or ignored, and represent a significant expense in traditional approaches to software development. Often these needs are met by developing a largely unrelated version of the application, requiring maintenance of additional, separate code bases. Our aim is to enable Inclusive Design [3], whose objective is to satisfy the needs and desires of the broadest range of users possible. Every designer sets out with this objective to a certain extent, but as well as limitations of intent, there are also strong limitations placed by the technology and economics of software development. Due to the poor scaling characteristics of current techniques, even meeting one set of relatively inflexible needs can be an expensive undertaking, especially over the long term. To address these problems of adaptability, we present a model for software construction, together with a base library, Fluid Infusion, implemented in the JavaScript language. Fluid Infusion implements an Inversion of Control model, Infusion IoC, which features a notion of context as the basis for adaptability, resolved in a scope modelled in terms of a data structure, a component tree expressing the computation to be performed. In the Context-Oriented Programming community [7], this model of scoping is known as structural scoping. We will also work with a model of transparent state in which all modifiable state of interest to users is held in publicly visible locations, indexed by path strings. This model for state is isomorphic to that modeled by JSON [6], a well-known state model derived from, but not limited to, the JavaScript language. Instantiation in the model is handled by an Inversion of Control system extended from the model of similar system such as the Spring Framework or Pico first developed in the Java language. We relate such systems to goal-directed resolution systems such as Prolog, and show that they have beneficial properties such as homoiconicity [2] which have not been seen in a strong or widespread form since the days of LISP. We exhibit some cases to show how the framework enables, through a simple declarative syntax, types of adaptation and composition that are hard or impossible using traditional models of polymorphism. We also relate Infusion IoC to other software methodologies such as Aspect-Oriented Programming and Context-Oriented Programming which have been found to greatly increase flexibility and expressiveness of designs. We conclude with some remarks on the applicability of the system to the parallelisation of irregular algorithms, and its relationship to upcoming developments in the ECMAScript 6 language specification.}},
    address = {New York, NY, USA},
    author = {Basman, Antranig M. and Lewis, Clayton H. and Clark, Colin B. D.},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10562086},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048220},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048220},
    doi = {10.1145/2048147.2048220},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {237--256},
    posted-at = {2012-04-13 15:08:45},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{To inclusive design through contextually extended IoC: infusion IoC, a JavaScript library and mentality for scalable development of accessible and maintainable systems}},
    url = {http://dx.doi.org/10.1145/2048147.2048220},
    year = {2011}
}

@inproceedings{Mirghasemi2011Naming,
    abstract = {{JavaScript developers create programs by calling functions and they use functions to construct objects. JavaScript development tools need to report to developers about those functions and constructors, for example in debugger call-stacks and in object representations. However, most functions are anonymous: developers need not to specify names for functions. Based on our analysis of ten large, widely used JavaScript projects, less than 7\% of JavaScript functions are named by developers. After studying examples from these JavaScript projects, we propose Static Function-Object Consumption, a principled, automated approach based on local source code analysis for providing names to nameless JavaScript functions. We applied our approach to 90000 anonymous functions that appeared in the analyzed JavaScript projects. The approach is successful in naming more than 99\% (91\% are unique within their file) of anonymous functions while the average length of function names is kept less than 37 characters.}},
    address = {New York, NY, USA},
    author = {Mirghasemi, Salman and Barton, John J. and Petitpierre, Claude},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10562085},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048222},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048222},
    doi = {10.1145/2048147.2048222},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {277--288},
    posted-at = {2012-04-13 15:08:36},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{Naming anonymous javascript functions}},
    url = {http://dx.doi.org/10.1145/2048147.2048222},
    year = {2011}
}

@inproceedings{Zakai2011Emscripten,
    abstract = {{We present Emscripten, a compiler from LLVM (Low Level Virtual Machine) assembly to JavaScript. This opens up two avenues for running code written in languages other than JavaScript on the web: (1) Compile code directly into LLVM assembly, and then compile that into JavaScript using Emscripten, or (2) Compile a language's entire runtime into LLVM and then JavaScript, as in the previous approach, and then use the compiled runtime to run code written in that language. For example, the former approach can work for C and C++, while the latter can work for Python; all three examples open up new opportunities for running code on the web. Emscripten itself is written in JavaScript and is available under the MIT license (a permissive open source license), at http://www.emscripten.org. As a compiler from LLVM to JavaScript, the challenges in designing Emscripten are somewhat the reverse of the norm - one must go from a low-level assembly into a high-level language, and recreate parts of the original high-level structure of the code that were lost in the compilation to low-level LLVM. We detail the methods used in Emscripten to deal with those challenges, and in particular present and prove the validity of Emscripten's Relooper algorithm, which recreates high-level loop structures from low-level branching data.}},
    address = {New York, NY, USA},
    author = {Zakai, Alon},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10562084},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048224},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048224},
    doi = {10.1145/2048147.2048224},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {301--312},
    posted-at = {2012-04-13 15:08:26},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{Emscripten: an LLVM-to-JavaScript compiler}},
    url = {http://dx.doi.org/10.1145/2048147.2048224},
    year = {2011}
}

@inproceedings{Bardin2011Improving,
    abstract = {{Modern applications are able to adapt their architecture dynamically in order to tackle requirements, correctives and context changes. Such dynamism is often an echo of complexity and is not well supported by traditional client and user software stacks making complex the design, implementation and maintenance of the end user interface. Meanwhile, the web has seen the emergence of user interface technologies (e.g. HTML5, CSS3, JavaScript) widely adopted by developers to create highly flexible user interfaces. However, such clients are intrinsically bound to run on a web browser which is out of the control of the application. In this paper, we present ChameRIA, an application framework where a browser engine is reified as a component within the framework, thus allowing for better control over the rendering engine. We describe how we preserve a clear separation of concerns between the user interface and the application logic while maintaining coherence between them. We discuss how ChameRIA has been successfully used in two projects: a DRM document reader and a valve control application.}},
    address = {New York, NY, USA},
    author = {Bardin, Jonathan M. and Lalanda, Philippe and Escoffier, Cl{\'{e}}ment and Murphy, Alice},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10562083},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048219},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048219},
    doi = {10.1145/2048147.2048219},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {225--236},
    posted-at = {2012-04-13 15:08:16},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{Improving user experience by infusing web technologies into desktops}},
    url = {http://dx.doi.org/10.1145/2048147.2048219},
    year = {2011}
}

@inproceedings{Nandivada2011Framework,
    abstract = {{There are several commercial products that use proprietary languages, which typically look like a wrapper around (some proprietary extension of) the standard SQL language. Examples of these languages include ABAP, Informix, XBase++, SQR and so on. These application are difficult to analyze not only because it is hard to model the semantics of the underlying database systems but also because of the lack of standard tools for analysis. One naive way to analyse such programs is to collect dynamic trace using proprietary debuggers and run the analyses on the trace. However, this form of dynamic trace collection can be a severe performance bottleneck. In this paper, we present our experience with building a framework to help in efficient program analysis in the context of ticket resolution for ABAP programs. In our framework, we first translate the given ABAP programs to semantically equivalent annotated Java programs. These Java programs are then executed to generate the required dynamic trace. Our framework allows the plugging of off-the-shelf static analysis tools (applied on the Java programs) and dynamic trace analysis tools (on the generated trace) and maps the results from these analysis tools back to the original ABAP programs. One novel aspect of our framework is that it admits incomplete ABAP grammar, which is an important aspect when dealing with proprietary languages where the grammar may not be publicly available. We have used our framework on several benchmarks to validate the translation, and establish the efficiency and the utility of our instrumented Java code along with the collected trace.}},
    address = {New York, NY, USA},
    author = {Nandivada, V. Krishna and Nanda, Mangala G. and Dhoolia, Pankaj and Saha, Diptikalyan and Nandy, Anjan and Ghosh, Anup},
    booktitle = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
    citeulike-article-id = {10514443},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2048223},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2048147.2048223},
    doi = {10.1145/2048147.2048223},
    isbn = {978-1-4503-0942-4},
    location = {Portland, Oregon, USA},
    pages = {289--300},
    posted-at = {2012-04-13 15:08:05},
    priority = {2},
    publisher = {ACM},
    series = {SPLASH '11},
    title = {{A framework for analyzing programs written in proprietary languages}},
    url = {http://dx.doi.org/10.1145/2048147.2048223},
    year = {2011}
}

@book{Nielsen1993Usability,
    abstract = {{An authoritative text by one of the premier researchers in usability engineering in the 1990s, Jakob Nielsen's <I>Usability Engineering</I> provides a landmark guide to software design that has helped bring this area of research into the mainstream of computing. "Usability" is the measurement of how easy or difficult it is to be productive with a piece of software. It often looks at the user interface--what elements appear onscreen and how efficient, confusing, and/or intuitive they are for beginning, intermediate, and advanced users. "Usability engineering" is the formal study of usability. It grew out of research on human factors, which looked at the way people interact with their environment.<p> The best thing about this book is its concise, cut-to-the-chase approach when defining usability and ways to measure and improve it. As the author notes, in the old days of computing, documents that attempted to define usability might have over 1,000 rules. The author offers just a handful of guiding principles for creating better software that apply even today. (Published just before the Internet revolution, this book's principles still hold true for Web designers, as well as those who create more traditional applications.)<p> Throughout this text, the author argues for the benefits of improved software usability. With software use as with all things, time is money and making more efficient interfaces translates into lower personnel costs and more productivity. The book also does a fine job of integrating usability design into the software development process, with guides for planning, working with end users, and running tests with users (whether on videotape or in person). The 50-page bibliography attests to the author's previous research on usability.<p> For anyone who needs to create better, more efficient software, <I>Usability Engineering</I> can help. This clear and intelligent guide to the science of usability engineering has helped enhance the potential of computers to work with end users more efficiently. In the new century, software developers will undoubtedly seek new advances in usability, in part because of the groundwork laid by books like this one. <I>--Richard Dragan</I><p> <B>Topics covered</B>: Usability basics, measuring usability, types of users, history of user interfaces, the usability engineering lifecycle, design techniques, heuristics and hints for improving usability, testing, managing user tests, assessing usability, interface standards, internationalization, and Computer-Aided Usability Engineering (CAUSE) tools.} {Written by the author of the best-selling <B>HyperText \& HyperMedia,</B> this book is an excellent guide to the methods of usability engineering. The book provides the tools needed to avoid usability surprises and improve product quality. Step-by-step information on which method to use at various stages during the development lifecycle are included, along with detailed information on how to run a usability test and the unique issues relating to international usability.<br><br>* Emphasizes cost-effective methods that developers can implement immediately<br>* Instructs readers about which methods to use when, throughout the development lifecycle, which ultimately helps in cost-benefit analysis. <br>* Shows readers how to avoid the four most frequently listed reasons for delay in software projects.<br>* Includes detailed information on how to run a usability test.<br>* Covers unique issues of international usability.<br>* Features an extensive bibliography allowing readers to find additional information.<br>* Written by an internationally renowned expert in the field and the author of the best-selling HyperText \& HyperMedia.}},
    author = {Nielsen, Jakob},
    citeulike-article-id = {634897},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0125184069},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0125184069},
    citeulike-linkout-10 = {http://www.worldcat.org/oclc/41525304},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0125184069},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0125184069},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0125184069/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0125184069},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0125184069},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0125184069},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0125184069\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0125184069},
    day = {23},
    edition = {1st},
    howpublished = {Paperback},
    isbn = {9780125184069},
    month = sep,
    posted-at = {2012-04-13 14:29:59},
    priority = {2},
    publisher = {Morgan Kaufmann},
    title = {{Usability Engineering}},
    url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0125184069},
    year = {1993}
}

@book{Nielsen1999Designing,
    abstract = {{From the Publisher: Can you afford to be less knowledgable than your competitors? Over 100,000 Internet professionals around the world have already bought this book. Users experience the usability of a site before they have committed to using it and before they have spent any money on potential purchases.  The web is the ultimate environment for empowerment, and he or she who clicks the mouse decides everything.  Jakob Nielson, shares with you the full weight of his wisdom and experience.  From content and page design to designing for ease of navigation and users with disabilities, Nielsen delivers complete direction on how to connect with any web user, in any situation. Nielsen has arrived at a series of principles that work in support of his findings\&\#58; 1. that web users want to find what they're after quickly, and 2. if they don't know what they're after, they nevertheless want to browse quickly and access information they come across in a logical manner.}},
    address = {Thousand Oaks, CA, USA},
    author = {Nielsen, Jakob},
    citeulike-article-id = {6172897},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=519216},
    isbn = {156205810X},
    keywords = {design, usability},
    posted-at = {2012-04-13 14:29:53},
    priority = {2},
    publisher = {New Riders Publishing},
    title = {{Designing Web Usability: The Practice of Simplicity}},
    url = {http://portal.acm.org/citation.cfm?id=519216},
    year = {1999}
}

@book{Shneiderman1997Designing,
    abstract = {{From the Publisher:In 1996, recognizing this book, ACM's Special Interest Group on Documentation (SIGDOC) presented Ben Shneiderman with the Joseph Rigo Award. SIGDOC praised the book as one "that took the jargon and mystery out of the field of human-computer interaction" and attributed the book's success to "its readability and emphasis on practice as well as research." In revising this best-seller, Ben Shneiderman again provides a complete, current, and authoritative introduction to user-interface design. The user interface is the part of every computer system that determines how people control and operate that system. When the interface is well designed, it is comprehensible, predictable, and controllable; users feel competent, satisfied, and responsible for their actions. In this book, the author discusses the principles and practices needed to design such effective interaction. Based on 20 years experience, Shneiderman offers readers practical techniques and guidelines for interface design. As a scientist, he also takes great care to discuss underlying issues and to support conclusions with empirical results. Interface designers, software engineers, and product managers will all find here an invaluable resource for creating systems that facilitate rapid learning and performance, yield low error rates, and generate high user satisfaction.

Coverage includes the human factors of interactive software (with added discussion of diverse user communities), tested methods to develop and assess interfaces, interaction styles (like direct manipulation for graphical user interfaces), and design considerations (effective messages, consistent screen design, appropriate color).}},
    address = {Boston, MA, USA},
    author = {Shneiderman, Ben},
    citeulike-article-id = {1314664},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=523237},
    edition = {3rd},
    isbn = {0201694972},
    keywords = {1997, hci},
    posted-at = {2012-04-13 14:25:13},
    priority = {2},
    publisher = {Addison-Wesley Longman Publishing Co., Inc.},
    title = {{Designing the User Interface: Strategies for Effective Human-Computer Interaction}},
    url = {http://portal.acm.org/citation.cfm?id=523237},
    year = {1997}
}

@inproceedings{Vikram2009Ripley,
    abstract = {{Rich Internet applications are becoming increasingly distributed, as demonstrated by the popularity of AJAX or Web 2.0 applications such as Facebook, Google Maps, Hotmail and many others. A typical multi-tier AJAX application consists, at least, of a server-side component implemented in Java J2EE, PHP or ASP.NET and a client-side component running JavaScript. The resulting application is more responsive because computation has moved closer to the client, avoiding unnecessary network round trips for frequent user actions. However, once a portion of the code has moved to the client, a malicious user can subvert the client side of the computation, jeopardizing the integrity of the server-side state. In this paper we propose Ripley, a system that uses replicated execution to automatically preserve the integrity of a distributed computation. Ripley replicates a copy of the client-side computation on the trusted server tier. Every client-side event is transferred to the replica of the client for execution. Ripley observes results of the computation, both as computed on the client-side and on the server side using the replica of the client-side code. Any discrepancy is flagged as a potential violation of computational integrity. We built Ripley on top of Volta, a distributing compiler that translates .NET applications into JavaScript, effectively providing a measure of security by construction for Volta applications. We have evaluated the Ripley approach on 5 representative AJAX applications built in Volta and also Hotmail, a large widely-used AJAX application. Our results so far suggest that Ripley provides a promising strategy for building secure distributed web applications, which places minimal burden on the application developer at the cost of a low performance overhead.}},
    address = {New York, NY, USA},
    author = {Vikram, K. and Prateek, Abhishek and Livshits, Benjamin},
    booktitle = {Proceedings of the 16th ACM conference on Computer and communications security},
    citeulike-article-id = {7883503},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1653685},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1653662.1653685},
    doi = {10.1145/1653662.1653685},
    isbn = {978-1-60558-894-0},
    location = {Chicago, Illinois, USA},
    pages = {173--186},
    posted-at = {2012-04-13 04:43:34},
    priority = {2},
    publisher = {ACM},
    series = {CCS '09},
    title = {{Ripley: automatically securing web 2.0 applications through replicated execution}},
    url = {http://dx.doi.org/10.1145/1653662.1653685},
    year = {2009}
}

@inproceedings{Meyerovich2009Flapjax,
    abstract = {{This paper presents Flapjax, a language designed for contemporary Web applications. These applications communicate with servers and have rich, interactive interfaces. Flapjax provides two key features that simplify writing these applications. First, it provides event streams, a uniform abstraction for communication within a program as well as with external Web services. Second, the language itself is reactive: it automatically tracks data dependencies and propagates updates along those dataflows. This allows developers to write reactive interfaces in a declarative and compositional style. Flapjax is built on top of JavaScript. It runs on unmodified browsers and readily interoperates with existing JavaScript code. It is usable as either a programming language (that is compiled to JavaScript) or as a JavaScript library, and is designed for both uses. This paper presents the language, its design decisions, and illustrative examples drawn from several working Flapjax applications.}},
    address = {New York, NY, USA},
    author = {Meyerovich, Leo A. and Guha, Arjun and Baskin, Jacob and Cooper, Gregory H. and Greenberg, Michael and Bromfield, Aleks and Krishnamurthi, Shriram},
    booktitle = {Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications},
    citeulike-article-id = {6095807},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1640089.1640091},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1640089.1640091},
    doi = {10.1145/1640089.1640091},
    isbn = {978-1-60558-766-0},
    location = {Orlando, Florida, USA},
    pages = {1--20},
    posted-at = {2012-04-13 02:12:40},
    priority = {2},
    publisher = {ACM},
    series = {OOPSLA '09},
    title = {{Flapjax: a programming language for Ajax applications}},
    url = {http://dx.doi.org/10.1145/1640089.1640091},
    year = {2009}
}

@article{Mesbah2012Crawling,
    abstract = {{Using JavaScript and dynamic DOM manipulation on the client side of Web applications is becoming a widespread approach for achieving rich interactivity and responsiveness in modern Web applications. At the same time, such techniques---collectively known as Ajax---shatter the concept of webpages with unique URLs, on which traditional Web crawlers are based. This article describes a novel technique for crawling Ajax-based applications through automatic dynamic analysis of user-interface-state changes in Web browsers. Our algorithm scans the DOM tree, spots candidate elements that are capable of changing the state, fires events on those candidate elements, and incrementally infers a state machine that models the various navigational paths and states within an Ajax application. This inferred model can be used in program comprehension and in analysis and testing of dynamic Web states, for instance, or for generating a static version of the application. In this article, we discuss our sequential and concurrent Ajax crawling algorithms. We present our open source tool called Crawljax, which implements the concepts and algorithms discussed in this article. Additionally, we report a number of empirical studies in which we apply our approach to a number of open-source and industrial Web applications and elaborate on the obtained results.}},
    address = {New York, NY, USA},
    author = {Mesbah, Ali and van Deursen, Arie and Lenselink, Stefan},
    citeulike-article-id = {10483884},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2109208},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2109205.2109208},
    doi = {10.1145/2109205.2109208},
    issn = {1559-1131},
    journal = {ACM Trans. Web},
    month = mar,
    number = {1},
    posted-at = {2012-03-21 17:46:34},
    priority = {2},
    publisher = {ACM},
    title = {{Crawling Ajax-Based Web Applications through Dynamic Analysis of User Interface State Changes}},
    url = {http://dx.doi.org/10.1145/2109205.2109208},
    volume = {6},
    year = {2012}
}

@inproceedings{Tilevich2008Program,
    abstract = {{Program enhancement refers to adding new functionality to an existing program. We argue that repetitive program enhancement tasks can be expressed as patterns, and that the application of such enhancement patterns can be automated. This paper presents a novel approach to pattern-oriented automated enhancement of object-oriented programs. Our approach augments the capabilities of an aspect compiler to capture the programmer's intent to enhance a program. In response to the programmer referencing a piece of functionality that is non-existent, our approach automatically synthesizes aspect code to supply the required functionality transparently. To improve flexibility and facilitate reuse, the synthesis and application of the new functionality is guided by declarative whenthen rules, concisely expressed using a rule base. Our extensible automated program enhancement system, called DRIVEL1, extends the AspectJ compiler with aspect generating capabilities. The generation is controlled using the DROOLS rules engine. To validate our approach and automated tool, we have created a collection of enhancement libraries and used DRIVEL to apply them to the LibX Edition Builder, a large-scale, widely-used Web application. DRIVEL automatically enhanced the LibX Edition Builder's XML processing modules with structural navigation capabilities and caching, eliminating the need to implement this functionality by hand.}},
    address = {New York, NY, USA},
    author = {Tilevich, Eli and Back, Godmar},
    booktitle = {Proceedings of the 7th international conference on Aspect-oriented software development},
    citeulike-article-id = {2796496},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1353482.1353485},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1353482.1353485},
    doi = {10.1145/1353482.1353485},
    isbn = {978-1-60558-044-9},
    location = {Brussels, Belgium},
    pages = {13--24},
    posted-at = {2012-01-24 05:13:51},
    priority = {2},
    publisher = {ACM},
    series = {AOSD '08},
    title = {{"Program, enhance thyself!":} demand-driven pattern-oriented program enhancement},
    url = {http://dx.doi.org/10.1145/1353482.1353485},
    year = {2008}
}

@book{Gamma1994Design,
    author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
    citeulike-article-id = {10258488},
    posted-at = {2012-01-24 03:10:47},
    priority = {2},
    publisher = {Addison-Wesley},
    title = {{Design Patterns: Elements of Reusable Object-Oriented Software}},
    year = {1994}
}

@techreport{BurbeckApplication,
    author = {Burbeck, Steve},
    citeulike-article-id = {10258486},
    howpublished = {http://st-www.cs.illinois.edu/users/smarch/st-docs/mvc.html},
    institution = {University of Illinois in Urbana-Champaign (UIUC)},
    posted-at = {2012-01-24 03:08:54},
    priority = {2},
    title = {{Application Programming in Smalltalk-80: How to use Model-View-Controller (MVC)}}
}

@techreport{Yoshino2011WebSocket,
    abstract = {{This specification defines a per-frame DEFLATE compression extension for the WebSocket protocol. This extension compresses the application data part of WebSocket data frames using DEFLATE.  Please send feedback to the hybi@ietf.org mailing list.}},
    address = {Fremont, CA, USA},
    author = {Yoshino, Takeshi},
    citeulike-article-id = {10253646},
    citeulike-linkout-0 = {http://www.rfc-editor.org/internet-drafts/draft-tyoshino-hybi-websocket-perframe-deflate-04.txt},
    citeulike-linkout-1 = {http://tools.ietf.org/html/draft-tyoshino-hybi-websocket-perframe-deflate-04},
    citeulike-linkout-2 = {http://tools.ietf.org/id/draft-tyoshino-hybi-websocket-perframe-deflate-04.txt},
    day = {3},
    howpublished = {Working Draft},
    institution = {IETF Secretariat},
    month = aug,
    number = {draft-tyoshino-hybi-websocket-perframe-deflate-04.txt},
    posted-at = {2012-01-23 03:50:19},
    priority = {2},
    publisher = {IETF Secretariat},
    title = {{WebSocket Per-frame DEFLATE Extension}},
    url = {http://www.rfc-editor.org/internet-drafts/draft-tyoshino-hybi-websocket-perframe-deflate-04.txt},
    year = {2011}
}

@inproceedings{Adya2002Cooperative,
    abstract = {{An abstract is not available.}},
    address = {Berkeley, CA, USA},
    author = {Adya, Atul and Howell, Jon and Theimer, Marvin and Bolosky, William J. and Douceur, John R.},
    booktitle = {Proceedings of the General Track of the annual conference on USENIX Annual Technical Conference},
    citeulike-article-id = {4959042},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=713851},
    isbn = {1-880446-00-6},
    pages = {289--302},
    posted-at = {2012-01-22 22:47:11},
    priority = {2},
    publisher = {USENIX Association},
    title = {{Cooperative Task Management Without Manual Stack Management}},
    url = {http://portal.acm.org/citation.cfm?id=713851},
    year = {2002}
}

@inproceedings{Stratmann2011Integrating,
    abstract = {{Long polling is a technique that simulates server push using Ajax requests, allowing Web pages to be updated quickly in response to server events. Unfortu nately, existing long poll approaches are difficult to use, do not work well with server-side frameworks based on the Model-View-Controller (MVC) pattern, and are not scalable. Vault is an architecture for long polling that integrates cleanly with MVC frameworks and scales for clustered environments of hundreds of application servers. Vault lets developers focus on writing application-specific code without worrying about the details of how long polling is implemented. We have implemented Vault in two different Web frameworks.}},
    address = {Berkeley, CA, USA},
    author = {Stratmann, Eric and Ousterhout, John and Madan, Sameer},
    booktitle = {Proceedings of the 2nd USENIX conference on Web application development},
    citeulike-article-id = {10251920},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2002178},
    location = {Portland, OR},
    pages = {10},
    posted-at = {2012-01-22 15:59:42},
    priority = {2},
    publisher = {USENIX Association},
    series = {WebApps'11},
    title = {{Integrating long polling with an MVC framework}},
    url = {http://portal.acm.org/citation.cfm?id=2002178},
    year = {2011}
}

@book{Chen2007ZK,
    abstract = {{An abstract is not available.}},
    address = {Berkely, CA, USA},
    author = {Chen, Henri and Cheng, Robbie},
    citeulike-article-id = {2363697},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1296201},
    isbn = {1590599012},
    keywords = {cloudbrowser},
    posted-at = {2012-01-18 14:48:52},
    priority = {2},
    publisher = {Apress},
    title = {{ZK: Ajax without the Javascript Framework}},
    url = {http://portal.acm.org/citation.cfm?id=1296201},
    year = {2007}
}

@incollection{Kiczales1997Aspectoriented,
    abstract = {{We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in  ” tangled” code that is excessively difficult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects , and show that the reason they have been hard to capture is that they cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspect-oriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code. The discussion is rooted in systems we have built using aspect-oriented programming.}},
    address = {Berlin/Heidelberg},
    author = {Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
    booktitle = {ECOOP'97 — Object-Oriented Programming},
    chapter = {10},
    citeulike-article-id = {3451508},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/BFb0053381},
    citeulike-linkout-1 = {http://www.springerlink.com/content/x535m642082k783r},
    doi = {10.1007/BFb0053381},
    editor = {Ak\c{s}it, Mehmet and Matsuoka, Satoshi},
    isbn = {3-540-63089-9},
    journal = {ECOOP'97 — Object-Oriented Programming},
    pages = {220--242},
    posted-at = {2012-01-18 03:22:10},
    priority = {2},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Aspect-oriented programming ECOOP'97 — Object-Oriented Programming}},
    url = {http://dx.doi.org/10.1007/BFb0053381},
    volume = {1241},
    year = {1997}
}

@inproceedings{Lowet2009Cobrowsing,
    abstract = {{Collaborative browsing, or co-browsing, is the co-navigation of the web with other people at-a-distance, supported by software that takes care of synchronizing the browsers. Current state-of-the-art solutions are able to do co-browsing of "static web pages", and do not support the synchronization of JavaScript interactions. However, currently many web pages use JavaScript and Ajax techniques to create highly dynamic and interactive web applications. In this paper, we describe two approaches for co-browsing that both support the synchronization of the JavaScript and Ajax interactions of dynamic web pages. One approach is based on synchronizing the output of the JavaScript engine by sending over the changes made on the DOM tree. The other approach is based on synchronizing the input of the JavaScript engine by synchronizing UI events and incoming data. Since the latter solution offers a better user experience and is more scalable, it is elaborated in more detail. An important aspect of both approaches is that they operate at the DOM level. Therefore, the client-side can be implemented in JavaScript and no browser extensions are required. To the best of the authors' knowledge this is the first DOM-level co-browsing solution that also enables co-browsing of the dynamic interaction parts of web pages. The presented co-browsing solution has been implemented in a research demonstrator which allows users to do co-browsing of web-applications on browser-based networked televisions.}},
    address = {New York, NY, USA},
    author = {Lowet, Dietwig and Goergen, Daniel},
    booktitle = {Proceedings of the 18th international conference on World wide web},
    citeulike-article-id = {4897560},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1526709.1526836},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1526709.1526836},
    doi = {10.1145/1526709.1526836},
    isbn = {978-1-60558-487-4},
    location = {Madrid, Spain},
    pages = {941--950},
    posted-at = {2012-01-11 16:46:46},
    priority = {2},
    publisher = {ACM},
    series = {WWW '09},
    title = {{Co-browsing dynamic web pages}},
    url = {http://dx.doi.org/10.1145/1526709.1526836},
    year = {2009}
}

@techreport{2000Document,
    citeulike-article-id = {10212535},
    citeulike-linkout-0 = {http://www.w3.org/TR/DOM-Level-2-Events/},
    day = {13},
    editor = {Pixley, Tom},
    month = nov,
    posted-at = {2012-01-10 20:30:12},
    priority = {2},
    title = {{Document Object Model (DOM) Level 2 Events Specification}},
    url = {http://www.w3.org/TR/DOM-Level-2-Events/},
    year = {2000}
}

@article{Mesbah2007Architectural,
    abstract = {{A new breed of Web application, dubbed AJAX, is emerging in response to a limited degree of interactivity in large-grain stateless Web interactions. At the heart of this new approach lies a single page interaction model that facilitates rich interactivity. We have studied and experimented with several AJAX frameworks trying to understand their architectural properties. In this paper, we summarize three of these frameworks and examine their properties and introduce the Spiar architectural style. We describe the guiding software engineering principles and the constraints chosen to induce the desired properties. The style emphasizes user interface component development, and intermediary delta-communication between client/server components, to improve user interactivity and ease of development. In addition, we use the concepts and principles to discuss various open issues in AJAX frameworks and application development.}},
    address = {Washington, DC, USA},
    author = {Mesbah, A. and van Deursen, A.},
    booktitle = {Software Architecture, 2007. WICSA '07. The Working IEEE/IFIP Conference on},
    citeulike-article-id = {2423473},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1264989},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/WICSA.2007.7},
    citeulike-linkout-2 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4077026},
    doi = {10.1109/WICSA.2007.7},
    isbn = {0-7695-2744-2},
    journal = {Software Architecture, 2007. WICSA '07. The Working IEEE/IFIP Conference on},
    month = jan,
    pages = {9},
    posted-at = {2011-11-07 15:56:43},
    priority = {2},
    publisher = {IEEE},
    title = {{An Architectural Style for Ajax}},
    url = {http://dx.doi.org/10.1109/WICSA.2007.7},
    year = {2007}
}

@inproceedings{Ousterhout2010Managing,
    abstract = {{Ajax-driven Web applications require state to be maintained across a series of server requests related to a single Web page. This conflicts with the stateless approach used in most Web servers and makes it difficult to create modular components that use Ajax. We implemented and evaluated two approaches to managing component state: one, called reminders, stores the state on the browser, and another, called page properties, stores the state on the server. Both of these approaches enable modular Ajax-driven components but they both introduce overhead for managing the state; in addition the reminder approach creates security issues and the page property approach introduces storage reclamation problems. Because of the subtlety and severity of the security issues with the reminder approach, we argue that it is better to store Ajax state on the server.}},
    address = {Berkeley, CA, USA},
    author = {Ousterhout, John and Stratmann, Eric},
    booktitle = {Proceedings of the 2010 USENIX conference on Web application development},
    citeulike-article-id = {9941236},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1863173},
    location = {Boston, MA},
    pages = {7},
    posted-at = {2011-10-24 16:25:07},
    priority = {2},
    publisher = {USENIX Association},
    series = {WebApps'10},
    title = {{Managing state for Ajax-driven web components}},
    url = {http://portal.acm.org/citation.cfm?id=1863173},
    year = {2010}
}

@article{Back2005KaffeOS,
    abstract = {{Single-language runtime systems, in the form of Java virtual machines, are widely deployed platforms for executing untrusted mobile code. These runtimes provide some of the features that operating systems provide: interapplication memory protection and basic system services. They do not, however, provide the ability to isolate applications from each other. Neither do they provide the ability to limit the resource consumption of applications. Consequently, the performance of current systems degrades severely in the presence of malicious or buggy code that exhibits ill-behaved resource usage. We show that Java runtime systems can be extended to support processes, and that processes can provide robust and efficient support for untrusted applications.We have designed and built KaffeOS, a Java runtime system that provides support for processes. KaffeOS isolates processes and manages the physical resources available to them: CPU and memory. Unlike existing Java virtual machines, KaffeOS can safely terminate processes without adversely affecting the integrity of the system, and it can fully reclaim a terminated process's resources. Finally, KaffeOS requires no changes to the Java language. The novel aspects of the KaffeOS architecture include the application of a user/kernel boundary as a structuring principle for runtime systems, the employment of garbage collection techniques for resource management and isolation, and a model for direct sharing of objects between untrusted applications. The difficulty in designing KaffeOS lay in balancing the goals of isolation and resource management against the goal of allowing direct sharing of objects.For the SpecJVM benchmarks, the overhead that our KaffeOS prototype incurs ranges from 0\&percent; to 25\&percent;, when compared to the open-source JVM on which it is based. We consider this overhead acceptable for the safety that KaffeOS provides. In addition, our KaffeOS prototype can scale to run more applications than running multiple JVMs. Finally, in the presence of malicious or buggy code that engages in a denial-of-service attack, KaffeOS can contain the attack, remove resources from the attacked applications, and continue to provide robust service to other clients.}},
    address = {New York, NY, USA},
    author = {Back, Godmar and Hsieh, Wilson C.},
    citeulike-article-id = {926086},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1075382.1075383},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1075382.1075383},
    doi = {10.1145/1075382.1075383},
    issn = {0164-0925},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {cloudbrowser},
    month = jul,
    number = {4},
    pages = {583--630},
    posted-at = {2011-10-24 16:13:27},
    priority = {5},
    publisher = {ACM},
    title = {{The KaffeOS Java runtime system}},
    url = {http://dx.doi.org/10.1145/1075382.1075383},
    volume = {27},
    year = {2005}
}

