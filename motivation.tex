\section{Motivation}
\label{sec:moti}

Our own experience includes the development of two substantial applications
using a server-centric approach~\cite{tilothesis,EdwardsBack:csc2011}:
an application to allow students to develop ZK applications in the cloud, and
a complex configuration management system.  This experience convinced
us of the feasibility and value of a server-centric approach.  In particular,
our users reported enjoying the user interface style we were able to
present, in which their actions took immediate effect~\cite{BaileyBack:igi2013}.
Notably, the latency introduced by server round trips did not present a
barrier to usability.

We soon felt hampered the lack of persistence across visits and no obvious way 
to solve it, other than to tie all variables controlling the application's
view to model variables that were, in turn, stored persistently in some way.
We hesitated to do that since we did not want to pollute our relatively clean
model that represented the business data of our application with less 
critical state solely intended to improve usability.

A second limitation that influenced our thinking was the mismatch between
server side representation (XUL) and the HTML used in the browser, which meant
that debugging layout issues became difficult since it required understanding
or reverse engineering how ZK's components were implemented.
Thus born was the idea to keep the presentation state in HTML on the server.

Keeping presentation state on the server imposes a cost that not all
types of applications may be willing to pay, even when the reduced development
effort is taken into account.  In~\cite{mcdaniel2012cloudbrowser}, we
discuss the types of applications for which we believe the trade-off we propose
may be worthwhile: personal and business applications such as tax preparation systems
or configuration management systems.  These applications are characterized by the following
traits:
\begin{itemize}
\item They are single-page applications with a large navigation space in which the
    user has free reign, thus remembering the exact view state is crucial for
    a satisfactory user experience.
\item Users expect that their actions take immediate effect, that is, almost every
    user input must trigger a communication with the server.
\item Users expect that updates to application state done by others become immediately
    reflected in their UI.
\end{itemize}

\subsection{Challenges}
\webscaleout{}
Successfully applying the idea of preserving presentation state in virtual
browsers kept in memory on the server imposes a number of challenges which this work 
makes an attempt to better understand.
These are related to user interface implementation, latency, 
resource consumption, scalability, and behavior in the presence of faults.

% Layout/Rendering.
A virtual browser does not lay out HTML elements or compute their styles in the
way that the rendering engine in the actual browser will, as doing so would be 
cost-prohibitive and not help at all when the user switches devices.  As such,
it cannot support inquiries by code about computed or user-determined
attributes such as what is the screen size, or what is the height of an
element after its layout has been computed.  We initially considered this is
a big impediment; however, in recent years, the dominant web design strategy
to deal with layout and placement has been a move to entirely CSS-based layouts
(e.g. Bootstrap), which adjust to screen sizes by using media CSS queries
to selectively apply styles.  In particular, in responsive design applications,
programmers are discouraged from directly inquiring about computed style
attributes.

% Latency.
A second concern is latency.  Since events are dispatched on the server,
the delay of a wide area network roundtrip is added to the processing delay,
along with any request queuing that may occur.  According to the human computer
interface literature, the resulting latency must not be larger than 100-150ms 
for the user to be perceived negatively.

% Memory & CPU Cost
A third concern is resource consumption, in particular memory and CPU consumption.
Virtual browsers will consume memory while they exist, and consume CPU time
while handling events.  Unfortunately, both JavaScript VMs, libraries, and
application frameworks were designed under the assumption that they run
on what is often a powerful client machine, which is particularly true for 
code that was prototyped quickly. This often means significant resource 
consumption.  We directly observed, however, that the requirement that JavaScript 
applications run on mobile devices is helping here because it forces both 
application and framework developers to optimize both CPU and memory 
consumption.

% Scaling/Fault Tolerance
A fourth concern, and which this paper particularly focuses on, is how to implement
scalability across multiple processes and/or machines. Related to that is the 
behavior of the system if server processes fail or must be restarted for other reasons.
Fig.~\ref{fig:webscaleout} shows the basic components of a scalable, multitier web 
application, which exists in numerous variations.  Scalability is achieved
by having a load balancer spread individual HTTP requests across multiple
web or application servers, which in turn talk to databases or other storage
providers.  In this model, the load balancer must be able to dispatch requests 
to any web server as web servers can be added and removed at will. To handle a 
request, a web server needs to have access to session state, which is replicated
and kept consistent across the web servers.  Though session state may be cached
in a web server's memory, it is stored in a way that allows for server processes
to restart.  At the same time, loss of session state is not catastrophic
as essential user data is stored in a separate storage layer.

In a scalable virtual browser environment, the load balancer is restricted
in the choice of web server to which to forward requests as soon as a virtual
browser is allocated.  Moreover, a crash or restart of a process housing a
virtual browser leads to the loss of all presentation state.  To prevent this
from catastrophic, applications will, as before, decide which part of their
state is deemed essential data that must be stored in the separate storage
layer.  In our lifecycle model, we have included a way in which such state
can be saved in checkpoints and restored upon restart.
From a practical point of view, this model means that detailed presentation
state may be lost in the case of a web server failure.
However, the perceived user impact of a loss of detailed presentation state 
is likely to decrease for virtual browsers that were less recently visited.

