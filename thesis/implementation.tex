\chapter{Implementation}
\label{ch:impl}
\markright{Implementation}

%Since virtual browsers occupy most of the system resources, the new
%distributed design spread the virtual browsers to multiple processes
%to improve the system's scalability.
\emph{put a paragraph in here saying the keypoints/highlights of what this chapter is about,
establishing a roadmap, keeps things in the order in which it'll be discussed.}

As shown in Figure~\ref{fig:cb2arch}, \cbtwo consists of a
single master process, multiple reverse proxies, and multiple worker
processes. All processes communicate via nodermi, which in turn uses standard TCP/IP 
sockets in its transport layer, so they can
be located on a shared-memory multiprocessor machine or on different machines in a cluster. 
Worker processes host application instances and virtual browsers. The master process is responsible for
the request dispatch logic which decides how to distribute the client load to
workers. The actual dispatching is implemented by the reverse proxies, which
forward users' requests to workers and copy workers' responses back to users.
All reverse proxy processes are bound to the socket that accepts client
requests, allowing the OS to distribute pending client connections in a round-
robin fashion.
The reverse proxy can relay both HTTP requests/responses as
well as the bidirectional WebSocket protocol (see Section~\ref{sec:nodepackage}).
Once the client has established a WebSocket connection with
the server side, the majority of traffic will be WebSocket
messages for which there is relatively little per-message overhead.

\newarchitectureoverview{}


% The master process is a single point of failure,
% but it is light weight and does less computation,
% so it is less likely to fail in practice.

% discuss the user request, message flow

\section{Request Dispatch}
\label{sec:reqdis}
% ---- motivation, use cases here
% ---- make it clear that after dispatch, the messages websocket

When a request is being dispatched, the reverse proxy uses information
contained in the request URL to make an appropriate forwarding decision. 
The system exposes three types of URLs for the users to access \cb applications.
The formats of these URLs are as follows:

\begin{description}

\item[Application URL] \label{itm:appurl} \hfill \\
Format: \url{http://example.com/[app]}, \code{[app]} represents an
application's mount point.   For example, if an application's mount point is
\emph{chat},  then its Application URL is \url{http://example.com/chat}.


\item[\appins{} URL] \label{itm:appinsurl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]},
\code{[appInstanceId]} represents an \appins{}'s id.  For example, if an
\appins{}'s id is \emph{appins1} and its application's mount point is
\emph{chat}, then its \appins{} URL is
\url{http://example.com/chat/a/appins1}.


\item[Browser URL] \label{itm:vburl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]/b/[browserId]},
\code{[browserId]} represents a virtual browser's id. For example, if a
virtual browser's id is \emph{browser1} and its \appins{} id is 
 \emph{appins1} and its application's mount point is \emph{chat},
  then the virtual browser's
Browser URL is \url{http://example.com/chat/a/appins1/b/browser1}.

\end{description}

% justify why you included /a and /b (for clarity?)

% -----scenario of these URLs, when low load, the reverse proxy could be embedded

For all application instantiation strategies (discussed in
Section~\ref{sec:appinstantiation}), the user may prefer to access
the application using the \emph{Application URL} because it is easy to
remember and it leads to a default view where user can navigate to other
views (if he has any).  
From the user's point of view,
the \emph{Application URL} is similar to the homepage URL in a traditional web application.

\emph{the above sounds vague}

For \emph{singleAppInstance}   and \emph{singleInstancePerUser}
applications where the user can access only one virtual browser, the system
redirects the user to that virtual browser when handling \emph{Application URL}. 
For \emph{singleBrowserPerUser} and \emph{multiInstance} applications, the
system will present the user a landing page listing all his \appins{}s and
virtual browsers when handling \emph{Application URL}. From there the user can
access any of his \appins{}.

\emph{include screenshot of landing page}.

\emph{\appins{} URLs} are used for joining a specific, already created \appins{}.  
For \emph{singleBrowserPerUser} applications where each user
can create only  one virtual browser for a given \appins{}, the system directs
the user to his own virtual browser in the specified \appins{} when handling
\emph{\appins{} URL}. 

For \emph{multiInstance} applications, it is the user's responsibility
to decide whether they wish to join an existing virtual browser or create a new one,
the system will lead the user to a landing page to make that decision.
For \emph{singleBrowserPerUser} and \emph{multiInstance} applications,
users can share an \appins{} with others by sharing its \emph{\appins{} URL}.

\appins{} URLs are not meaningful for \emph{singleAppInstance}   and
\emph{singleInstancePerUser} applications because there is only one \appins{}
for a given user. 

\emph{Browser URLs} are for connecting to a specific virtual browser. A user can
bookmark a \emph{Browser URL} so he can revisit that specific  virtual browser
in the future. The user can also share a virtual browser with other people by
sharing its \emph{Browser URL}.

As discussed in Section~\ref{sec:deploymodel}, multiple virtual browsers
may share data structures belonging to an \appins{}.
\cbtwo colocates every \appins and its virtual browsers in the same worker process.
Once an \appins has been created in a particular worker process, all future
requests to \emph{\appins{} URL}s and \emph{Browser URL}s for that instance's
ID must be routed to that worker.

\emph{ say something like when a app/inst or vb is created, user is redirected
... maybe this is already described below?}

%Application URL}s, the system need first allocate an \appins{} and virtual
%browser to handle the request according to the instantiation strategy, and then
%redirect the request with the virtual browser's URL.

Although the reverse proxy processes are in charge of the actual forwarding,
the master process keeps track of the forwarding map. Thus,
when a client sends a HTTP request, a reverse proxy process
will accept this HTTP request and ask the master where to dispatch this request. 

If the request URL is a \emph{Browser URL} or \emph{\appins URL}, 
the master extracts \appins id from the URL and returns the associated
worker via a \appins id to worker lookup table.
This lookup table is updated every time an \appins{} is created or removed.
For an \emph{\appins URL} request, the worker will continue to find the associated
virtual browser for the user and send back a redirect with the virtual browser's URL.

If the request URL is an \emph{Application URL}, 
the system's behavior varies according to the application's instantiation strategy.
For example, for a \emph{singleInstancePerUser} application,
the system can either create a new \appins{} for the user if the user does not have an
\appins or use the user's existing \appins{} if otherwise.
The instantiation strategy specific logic is handled by workers, not the master,
because it requires access to authentication information.
Thus, the master can pick any worker using a load
balance algorithm (detailed in Section~\ref{sec:lb}),
and the selected worker will then process the request according
to the instantiation strategy.
After consulting the authentication information, this worker will redirect 
the client to a specific Browser URL.   The virtual browser corresponding
to that URL may be located in another worker process.

When a worker process receives a Browser URL request, it will locate the
corresponding virtual browser and responds with an HTML document that contains
information to bootstrap the client engine. 
The client engine will create a WebSocket connection to establish an RPC channel to
the worker process.
First, the client engine sends a WebSocket handshake request to initiate the
WebSocket connection.
The handshake request URL contains the associated \appins id and virtual browser
id so the master can find the corresponding worker for this request.
After the worker sends back the handshake response, the connection
between the worker and the reverse proxy that performed the handshake, 
as well as the connection between the reverse proxy and the user remains open. 
The reverse proxy will relay all subsequent WebSocket messages
without parsing them and without requiring repeated calls to the master
to obtain forwarding information.

As the client engine renders the client-side view of the page, it may trigger
requests for auxiliary resources such as images or spreadsheets. 
These requests will contain the \appins{} id in the URL, which the master
uses to forward those requests to the appropriate worker.

%If any exception happens, for example, the user sends a Browser URL with no
%corresponding virtual browser in the system, the system will reject the
%request with an error message.

In this design, the reverse proxies ask the master for the dispatch decision
for every HTTP request.  However, HTTP requests are required only when users
reconnect to virtual browsers - most of the actual interaction with a virtual
browser is performed using RPC messages carried over WebSocket connections.
Thus, the overhead of inter-process communication between the reverse proxies and
the master to obtain forwarding information affects only a small portion of the network traffic. 

We also provide an option to embed a reverse proxy instance inside the master process.
If the system is configured with one single embedded reverse proxy,
reverse proxy and master can communicate directly.
However, in this mode, the system can support fewer concurrent users than 
when using multiple reverse proxies.

\section{Load Balancing}
\label{sec:lb}

The load balancing algorithm is invoked in two scenarios:
First, when the user requests an \emph{Application URL},
the master needs to find a worker to handle this request.
Second, it is invoked when the system is about to create a \appins{}.
Although such action can originate in any worker,
the load balancing algorithm is performed by the master.

For other user requests the routing is determined by the \appins{}-to-worker map
so there is no need for load balancing.
In particular, the creation of virtual browsers is not subject to load balancing.
Virtual browsers have to be placed in the same worker that hosts its \appins{}.

We support two load balancing strategies: first, the master can assign the
load to workers in a simple round-robin fashion. However, since \appins{}s may
vary widely in terms of the actual cost they impose on a worker and \appins{}s
can be terminated, the round-robin assignment works well only for cases in 
which resource use is uniformly distributed.
We also implemented a load-based scheme in which
workers periodically report a measure of current load to the master. The
master will select the worker with the lowest load when making load balancing decisions.
We have found the amount of heap memory that is currently in use a good measure
of a worker's momentary load.

In the load-based mode, the master's knowledge of a worker's load is not
always up-to-date as the worker's load can change before the master receives the
next report from the worker. We have found that this can lead to very unbalanced load
distributions. For example, when the system is creating a burst of \appins{}s,
they are all assigned to the same worker that has the lowest load at that
moment and this worker ends up hosting a disproportionate load.  To mitigate
this issue,  after the load balancing algorithm selects a worker, the
algorithm makes a projection of the worker's load after accepting the new
load. The projected value is used as the worker's load value  until the master
sees the worker's next report.  We have found it unnecessary to exactly 
predict the amount of incremental load as long as we do not significantly 
underpredict.  Based on our evaluation, a virtual
browser in a non-trivial application takes about 6M.  The master projects a
worker's load increase by 10M for every new \appins assignment assuming every
\appins will create 1 or 2 virtual browsers.  For most cases, the master
overestimates the actual load increase. It is not a problem because the master
corrects its estimate as soon as it sees the worker's next report. 
% ???
%In our experience, even under bursts of new requests the load distribution among the
%workers does not vary greatly.

\section{Master Implementation}

When the master process starts up, it initiates the following modules:

\begin{description}
\item[Application Manager] \hfill \\
Application Manager is responsible to maintain the state of applications. It
reads the application bundles (discussed in Section~\ref{sec:deploymodel}) and
initiate data structures to represent applications.

\item[Worker Manager] \hfill \\
Worker manager is responsible for the request dispatch
and the load balance algorithm (detailed in Section~\ref{sec:lb}).

\item[Reverse Proxy Manager] \hfill \\
Reverse proxy manager starts multiple reverse proxy processes as child
processes of the master and handles queries from them.
% the queries are sent from pipe, called ipc channel in node.js
% https://github.com/joyent/node/blob/master/lib/child_process.js
\end{description}

After initiation, the master exposes \emph{Application Manager} and
\emph{Worker Manager} to the workers via nodermi's \code{registerObj}  method
(discussed in Chapter~\ref{ch:rmi}).

The \emph{Application Manager} has application management related  methods,
such as list applications, create a new application, remove an application,
etc.  The applications are represented by application objects. An application
object has methods to maintain the internal state of the application, such as
change the application's authentication policy, register a new \appins, remove
an \appins, etc.  Since \emph{Application Manager} is registered in nodermi,
the worker can remote reference to it and get remote references to application
objects by calling its methods remotely. Via remote method invocation of
\emph{Application Manager} and application objects, the worker can get
metadata of all applications and register \appins{}s.  The worker also passes
reference to its own \emph{Application Manager}  and application objects to
the master's \emph{Application Manager} via remote method invocation.  The
master \emph{Application Manager}  uses remote references to these worker
objects to push application-related changes to the  workers.  For instance,
the master calls  the worker's  \code{addApplication} method remotely   to
push new application to that worker and remove an application from that worker
by calling the worker's \code{removeApplication} method remotely.

The \emph{Worker Manager} contains methods for worker to register its HTTP
hostname/port and report its load. It also maintains a table of \appins{} id
to worker HTTP hostname/port. This table is updated every time a \appins{}
is registered or removed from the \emph{Application Manager}.




\section{Worker Implementation}
\label{sec:worker}

For each worker, the system administrator needs to specify a hostname/port
pair the worker listens for HTTP requests,  the master's nodermi instance's
hostname/port, and a hostname/port for its own nodermi instance in a
configuration file. To ease the deployment effort, we provide a tool that can
generate multiple worker configuration files. Based on the information in the
configuration file, the worker creates a HTTP server and a nodermi instance.
After creating its internal modules, the worker process obtains remote
references to the master's \emph{Application Manager} and \emph{Worker
Manager} via nodermi, then  it fetches all the applications' metadata and
registers itself to the master by invoking methods of these remote references.
If the master is not running, the worker will keep on retrying until these
remote references are obtained.


The worker process maintains the mappings of \appins{} ids to its local
\appins{}s and browser ids to its local virtual browsers.
It tries to handle incoming HTTP requests with its local virtual browser
if possible.
When a worker receives a HTTP request, it parses the request to extract
\appins id, virtual browser id and get associated user information
from session. If the request does not
have an \appins id, the worker will find an existing virtual browser in the
system or tell the master to create a new one based on the application
instantiation strategy. After
that, the worker sends back a redirect response with the virtual browser's
\emph{Browser URL}. If the request has an \appins id, the worker first check
if the id matches any local \appins and rejects the request if the check
fails. If the request does not have a virtual browser id, the worker either
picks an existing virtual browser in the \appins  or create a new one based on
the application instantiation strategy, then the worker sends back a redirect
response with  the virtual browser's \emph{Browser URL}. If the request has a
virtual browser id and it matches a virtual browser in the \appins, the worker
processes the request based on the type of the request: For \emph{Browser URL}
requests, the worker sends back the initial  HTML document; For resource
requests, the virtual browser will read the corresponding local resource files
from file system or from Internet, and send back the content. For WebSocket
handshake requests, the worker would send back a handshake response message
and add the WebSocket connection to the virtual browser.
The subsequent WebSocket messages will be directly handled by the virtual browser.


% If the application requires authorization in the configuration, the
% worker would also check if the user has the permission to access the \appins
% or virtual browser specified in the request. The framework has a default
% permission policy that is useful for most cases. For example, by default the
% user could only access the virtual browsers he creates. We also provide a
% default web interface for users to manage the permissions of their \appins{}s
% and virtual browsers. The programmer could also explicitly manage user
% permissions in application code.

\input{api}
