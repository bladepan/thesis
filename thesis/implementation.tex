\chapter{Implementation}
\label{ch:impl}
\markright{Implementation}

\newarchitectureoverview{}

Since virtual browsers occupy most of the system resource, the new
distributed design spread the virtual browsers to multiple processes
to improve the system's scalability.
As shown in Figure~\ref{fig:cb2arch}, \cbtwo consists of a
single master process, multiple reverse proxies, and multiple worker
processes. All processes communicate via standard TCP/IP sockets, so they can
be located on a shared multiprocessor machine or in a cluster. The workers
host application instances and virtual browsers. The master is responsible for
the request dispatch logic which decides how to distribute the client load to
workers. The actual dispatching is implemented by the reverse proxies, they
forward users' requests to workers and copy workers' responses back to users.
The reverse proxy processes are bound to the socket that accepts client
requests, allowing the OS to distribute pending client connections in a round-
robin fashion.
The reverse proxy can relay both HTTP requests/responses as
well as the bidirectional WebSocket protocol (see Section~\ref{sec:nodepackage}).
Once the client established WebSocket connection with
the server side, the majority of traffic will be WebSocket
messages for which there is relatively little per-message overhead.


% The master process is a single point of failure,
% but it is light weight and does less computation,
% so it is less likely to fail in practice.

% discuss the user request, message flow

\section{Request Dispatch}
\label{sec:reqdis}
% ---- motivation, use cases here
% ---- make it clear that after dispatch, the messages websocket


For \cb{} applications, we expose the following three types of URL
to the end user.

\begin{description}

\item[Application URL] \label{itm:appurl} \hfill \\
Format: \url{http://example.com/[app]}, \code{[app]} represents an
application's mount point.   For example, if an application's mount point is
\emph{chat},  then its Application URL is \url{http://example.com/chat}.


\item[\appins{} URL] \label{itm:appinsurl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]},
\code{[appInstanceId]} represents an \appins{}'s id.  For example, if an
\appins{}'s id is \emph{appins1} and its application's mount point is
\emph{chat}, then its \appins{} URL is
\url{http://example.com/chat/a/appins1}.


\item[Browser URL] \label{itm:vburl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]/b/[browserId]},
\code{[browserId]} represents a virtual browser's id. For example, if a
virtual browser's id is \emph{browser1} and its \appins{} id is 
 \emph{appins1} and its application's mount point is \emph{chat},
  then the virtual browser's
Browser URL is \url{http://example.com/chat/a/appins1/b/browser1}.

\end{description}
% -----scenario of these URLs, when low load, the reverse proxy could be embedded

For all application instantiation strategies (discussed in
Section~\ref{sec:appinstantiation}), \emph{Application URL} is a convenient
way for the user to access the application. Like in a traditional web
application, users prefer to access the application using the homepage URL
because it is easy to remember and they can navigate to other pages from the
home page. For \emph{singleAppInstance}   and \emph{singleBrowserPerUser}
applications where the user can access only one   virtual browser, the system
redirects the user to that virtual browser when handling \emph{Application
URL}. For \emph{singleUserInstance} and \emph{multiInstance} applications, the
system will present the user a landing page listing all his \appins{}s and
virtual browsers when handling \emph{Application URL}. The landing page is
equivalent to the home page in a traditional web application. The user can
access any of his \appins{} via the landing page.


\emph{\appins{} URL} is used for joining  a specific \appins{}.  It is not
directly exposed to the end users in \emph{singleAppInstance}   and
\emph{singleBrowserPerUser} applications because there is only one \appins{}
for a given user. For \emph{singleUserInstance} applications where each user
can create only  one virtual browser for a given \appins{}, the system directs
the user to his own virtual browser in the specified \appins{} when handling
\emph{\appins{} URL}, the system will create new virtual browser if the
\appins{} does not have the user's virtual browser. For \emph{multiInstance}
applications, the system will present the user the landing page when handling
the \appins{} URL, it is the user's responsibility to decide either joining an
existing virtual browser or create a new one. For \emph{singleUserInstance}
and \emph{multiInstance} applications, users can share an \appins{} with
others by sharing its \emph{\appins{} URL}.


\emph{Browser URL} is for joining a specific virtual browser. The user can
bookmark a \emph{Browser URL} so he can revisit that specific  virtual browser
in the future. The user can also share a virtual browser with other people by
sharing its \emph{Browser URL}.



To preserve the semantics of \appins (discussed in Section~\ref{sec:appins})
that virtual browsers in an \appins could directly share data structure, each
\appins and its virtual browsers must be allocated in the same worker process
as emphasized in Figure~\ref{fig:appidhierarchy}. The master keeps a lookup
table of \appins id to worker process mappings.  When the request URL contains
an \appins id,  the master could find the corresponding worker right away.

When the client sends a HTTP request to the system, a reverse proxy process
will accept this HTTP request and ask the master where to dispatch this
request. If \appins id is in the request URL, the master would find a worker
via the lookup table. Otherwise, the master would find a worker using load
balance algorithm detailed in Section~\ref{sec:lb}. The reverse proxy then
forwards the request to the worker process. If the request URL does not
contain virtual browser id, the worker process would allocate a new virtual
browser or find an existing virtual browser in the system and sends back a
redirect response with the virtual browser's Browser URL. Upon receiving the
redirect response, the user will send another HTTP request with the Browser
URL.

When a worker process receives a Browser URL request, it will locate the
corresponding virtual browser and responds a HTML document that contains
information to bootstrap the client engine. The client engine will create a
WebSocket connection to synchronize DOM nodes. First, the client engine sends
a WebSocket handshake request which is a HTTP request to initiate the
WebSocket connection, the \appins id is embedded in the handshake request URL.
Like we discussed, a reverse proxy will receive this request and forward it to
the worker. After the worker send back the handshake response, the connection
between the worker and the reverse proxy, and the connection between the
reverse proxy and the user remains open. Subsequent WebSocket messages will go
through these two opened connections to forward user events and synchronize
DOM states for the specific virtual browser. The reverse proxy will just copy
the WebSocket messages back and forth without parsing them.

If any exception happens, for example, the user sends a Browser URL with no
corresponding virtual browser in the system, the system will reject the
request with an error message.

After client engine establishes WebSocket connections, the client could send
additional HTTP requests to fetch resources such as stylesheets, images, etc.
Since the URLs for these resources contains the current \appins id and virtual
browser id, these request could be dispatched to the right worker and  served
without redirect.

In this design, the reverse proxies ask the master for the dispatch decision
for every HTTP request.  Since the majority of the system's network traffic
are WebSocket messages and they do not need to invoke dispatch logic,  this
overhead of inter-process communication between the master and the reverse
proxies   only affects a small portion of the network traffic. We also provide
an option to embed a reverse proxy instance inside the master process. The
embedded reverse proxy  communicates with the master via method calls thus no
inter-process overhead is introduced.

\section{Load Balancing}
\label{sec:lb}

% ------- explain when lb decision is been made, don't introduce new term


When the master receives a user request that does not contain an \appins id,
since the master does not contain application logic,
it does not know if the system will create a new \appins{} for
the request or redirect the request to an existing \appins{},
the master needs to find a worker and let the worker to handle 
the request.
To dispatch these requests evenly, the master needs to call the load
balancing algorithm to select workers.

When a new \appins{} is going to be created,
the system needs to select a worker process to place it.

% For a user request that contains an \appins id,
% the master can only dispatch it to the worker that has the associated \appins{}.
%-------------- 


We support two load balancing strategies: first, the master can assign the
load to workers in a simple round-robin fashion. However, since \appins{}s may
vary widely in terms of the actual cost they impose on a worker and \appins{}s
can be terminated,  the round-robin assignment only works well for simple use
cases like benchmarking. We also implemented a load-based scheme in which
workers periodically report a measure of current load to the master. The
master will select the worker with the lowest load when placing new load.  We
have found the amount of heap memory that is currently in use a good measure
of a worker's  momentary load.

In the load-based mode,  the worker's load could change during the interval
between the worker's updates, and the master's knowledge is not updated. This
could lead to problematic load distribution. For example,  when the system is
creating a burst of \appins{}s, they could all be assigned to the same worker
that has the lowest load at that moment.  This could cause extremely uneven
load distribution. To mitigate this issue,  after the load balancing algorithm
selects a worker, the algorithm makes a projection of the worker's load. Based
on our evaluation, a virtual browser in a non-trivial application takes about
6M.  We increase a worker's load by 10M for every new \appins assignment
assuming each \appins will have 1 or 2  virtual browsers. Although this
estimate is not accurate, the worker's load will be fixed upon receiving next
load update. In this way, even under bursts of new requests,  the load
distribution between the workers would not vary greatly.



\section{Master Implementation}

When the master process starts up, it initiates the following modules:

\begin{description}
\item[Application Manager] \hfill \\
Application Manager is responsible to maintain the state of applications. It
reads the application bundles (discussed in Section~\ref{sec:deploymodel}) and
initiate data structures to represent applications.

\item[Worker Manager] \hfill \\
Worker manager is responsible for the request dispatch
and the load balance algorithm (detailed in Section~\ref{sec:lb}).

\item[Reverse Proxy Manager] \hfill \\
Reverse proxy manager starts multiple reverse proxy processes as child
processes of the master and handles queries from them.
% the queries are sent from pipe, called ipc channel in node.js
% https://github.com/joyent/node/blob/master/lib/child_process.js
\end{description}

After initiation, the master exposes \emph{Application Manager} and
\emph{Worker Manager} to the workers via nodermi's \code{registerObj}  method
(discussed in Chapter~\ref{ch:rmi}).

The \emph{Application Manager} has
methods to list all applications, to create a new application, to  remove an
application, etc. Each application object has methods to maintain the internal
state of the application, such as change the application's authentication
policy, register a new \appins, remove an \appins, etc. The worker invoke
these methods remotely to obtain metadata of all applications, register an
\appins, etc. The worker also register its own \emph{Application Manager}  and
application objects to the master's \emph{Application Manager}  via remote
method invocation. The master \emph{Application Manager}  uses stubs to these
worker objects to push changes to the  workers. For instance, the master uses
stubs to the worker's \emph{Application Manager} to push new application to
that worker and remove an application from that worker.

The \emph{Worker Manager} contains methods for worker to register its HTTP
hostname/port and report its load. It also maintains a table of \appins{} id
to worker HTTP hostname/port. This table is updated every time a \appins{}
is registered or removed from the \emph{Application Manager}.




\section{Worker Implementation}
\label{sec:worker}

When a worker process starts up, it first reads a configuration file that
specifies the port it is going to listen for HTTP requests,  the hostname/port
pair of the master process's nodermi instance   and the hostname/port pair for
its own nodermi instance. After initializing, the worker process obtains
remote references to the master's \emph{Application Manager} and \emph{Worker
Manager} via nodermi, then  it fetches all the applications' metadata and
registers itself to the master by invoking methods of these remote references.
If the master is not running, the worker will keep on retrying until the
remote references are obtained.

% ------ mapping bid to browser is in worker, make it clear, use html5 history
% to change url in location bar
The worker process maintains the mappings of \appins{} id to its local
\appins{}s and browser id to its local virtual browsers.
When a worker receives a HTTP request, it parses the request to extract
\appins id, virtual browser id and user information. If the request does not
have an \appins id, the worker would find an existing virtual browser in the
system or tell the master to create a new one  based on the application
instantiation strategy discussed in Section~\ref{sec:appinstantiation}. After
that, the worker sends back a redirect response with the virtual browser's
\emph{Browser URL}. If the request has an \appins id, the worker first check
if the id matches any local \appins and rejects the request if the check
fails. If the request does not have a virtual browser id, the worker either
picks an existing virtual browser in the \appins  or create a new one based on
the application instantiation strategy, then the worker sends back a redirect
response with  the virtual browser's \emph{Browser URL}. If the request has a
virtual browser id and it matches a virtual browser in the \appins, the worker
processes the request based on the type of the request: For \emph{Browser URL}
requests, the worker sends back the initial  HTML document; For resource
requests, the virtual browser will read the corresponding local resource files
from file system or from Internet, and send back the content. For WebSocket
handshake requests, the worker would send back a handshake response message
and add the connection to the virtual browser.


If the application requires authorization in the configuration, the
worker would also check if the user has the permission to access the \appins
or virtual browser specified in the request. The framework has a default
permission policy that is useful for most cases. For example, by default the
user could only access the virtual browsers he creates. We also provide a
default web interface for users to manage the permissions of their \appins{}s
and virtual browsers. The programmer could also explicitly manage user
permissions in application code.

\input{api}
