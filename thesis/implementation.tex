\chapter{Implementation}
\label{ch:impl}
\markright{Implementation}

This chapter first discusses the overview of the multi-process architecture of \cbtwo.
Then we discuss how client requests are dispatched and how load balancing is implemented.
After that we discuss the implementation of different \cbtwo processes and how they interact
with each other.
In the end we discuss how \cb applications access the framework internal objects.

%Since virtual browsers occupy most of the system resources, the new
%distributed design spread the virtual browsers to multiple processes
%to improve the system's scalability.


As shown in Figure~\ref{fig:cb2arch}, \cbtwo consists of a
single master process, multiple reverse proxies, and multiple worker
processes. All processes communicate via nodermi, which in turn uses standard TCP/IP 
sockets in its transport layer, so they can
be located on a shared-memory multiprocessor machine or on different machines in a cluster. 
Worker processes host application instances and virtual browsers. The master process is responsible for
the request dispatch logic which decides how to distribute the client load to
workers. The actual dispatching is implemented by the reverse proxies, which
forward users' requests to workers and copy workers' responses back to users.
All reverse proxy processes are bound to the socket that accepts client
requests, allowing the OS to distribute pending client connections in a round-
robin fashion.
The reverse proxy can relay both HTTP requests/responses as
well as the bidirectional WebSocket protocol (see Section~\ref{sec:nodepackage}).
Once the client has established a WebSocket connection with
the server side, the majority of traffic will be WebSocket
messages for which there is relatively little per-message overhead.

\newarchitectureoverview{}


% The master process is a single point of failure,
% but it is light weight and does less computation,
% so it is less likely to fail in practice.

\section{Request Dispatch}
\label{sec:reqdis}

When a request is being dispatched, the reverse proxy uses information
contained in the request URL to make an appropriate forwarding decision. 
The system exposes three types of URLs for the users to access \cb applications.
The formats of these URLs are as follows:

\begin{description}

\item[Application URL] \label{itm:appurl} \hfill \\
Format: \url{http://example.com/[app]}, \code{[app]} represents an
application's mount point.   For example, if an application's mount point is
\emph{chat},  then its Application URL is \url{http://example.com/chat}.


\item[\appins{} URL] \label{itm:appinsurl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]},
\code{[appInstanceId]} represents an \appins{}'s id.  For example, if an
\appins{}'s id is \emph{appins1} and its application's mount point is
\emph{chat}, then its \appins{} URL is
\url{http://example.com/chat/a/appins1}.


\item[Browser URL] \label{itm:vburl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]/b/[browserId]},
\code{[browserId]} represents a virtual browser's id. For example, if a
virtual browser's id is \emph{browser1} and its \appins{} id is 
 \emph{appins1} and its application's mount point is \emph{chat},
  then the virtual browser's
Browser URL is \url{http://example.com/chat/a/appins1/b/browser1}.

\end{description}

% TODO justify why you included /a and /b (for clarity?)

From the user's point of view, the \emph{Application URL} is similar to  the
homepage URL in a traditional web application. For a \emph{singleAppInstance}
or \emph{singleInstancePerUser} application, requesting \emph{Application URL}
redirects the user to the only virtual browser  he can access, the virtual
browser is created automatically if it did exist before the user request. For
a \emph{singleBrowserPerUser} or \emph{multiInstance} application, requesting
\emph{Application URL} redirects the user to the landing page
(Figure~\ref{fig:landingpage})  in which he can navigate to any of his virtual
browsers. The user may prefer use \emph{Application URL}s because it is easy
to remember and he can access his virtual browsers from \emph{Application
URL}s without bookmarking individual virtual browsers' URLs.

\landingpagefig{}


\emph{\appins{} URLs} are used for joining a specific, already created
\appins{}.   For \emph{singleBrowserPerUser} applications where each user can
create only  one virtual browser for a given \appins{}, the system directs the
user to his own virtual browser in the specified \appins{} when handling
\emph{\appins{} URL}.

For \emph{multiInstance} applications, it is the user's responsibility to
decide whether they wish to join an existing virtual browser or create a new
one, the system will lead the user to a landing page to make that decision.
For \emph{singleBrowserPerUser} and \emph{multiInstance} applications, users
can share an \appins{} with others by sharing its \emph{\appins{} URL}.

\appins{} URLs are not meaningful for \emph{singleAppInstance}   and
\emph{singleInstancePerUser} applications because there is only one \appins{}
for a given user.

\emph{Browser URLs} are for connecting to a specific virtual browser. A user
can bookmark a \emph{Browser URL} so he can revisit that specific  virtual
browser in the future. The user can also share a virtual browser with other
people by sharing its \emph{Browser URL}.

As discussed in Section~\ref{sec:deploymodel}, multiple virtual browsers may
share data structures belonging to an \appins{}. \cbtwo colocates every
\appins and its virtual browsers in the same worker process. Once an \appins
has been created in a particular worker process, all future requests to
\emph{\appins{} URL}s and \emph{Browser URL}s for that instance's ID must be
routed to that worker. When the user requests an \emph{Application URL},  the
system needs either allocate  a virtual browser  or redirect the user to a
landing page according to the application's instantiation strategy. Because the
landing page itself is a virtual browser,  the
system always allocates a virtual browser for the  user when handling user's
\emph{Application URL} request. Then the system redirects the user with the
virtual browser's URL.

%Application URL}s, the system need first allocate an \appins{} and virtual
%browser to handle the request according to the instantiation strategy, and then
%redirect the request with the virtual browser's URL.

Although the reverse proxy processes are in charge of the actual forwarding,
the master process keeps track of the forwarding map. Thus,
when a client sends a HTTP request, a reverse proxy process
will accept this HTTP request and ask the master where to dispatch this request. 

If the request URL is a \emph{Browser URL} or \emph{\appins URL}, 
the master extracts \appins id from the URL and returns the associated
worker via a \appins id to worker lookup table.
This lookup table is updated every time an \appins{} is created or removed.
For an \emph{\appins URL} request, the worker will continue to find the associated
virtual browser for the user and send back a redirect with the virtual browser's URL.

If the request URL is an \emph{Application URL}, 
the system's behavior varies according to the application's instantiation strategy.
For example, for a \emph{singleInstancePerUser} application,
the system can either create a new \appins{} for the user if the user does not have an
\appins or use the user's existing \appins{} if otherwise.
The instantiation strategy specific logic is handled by workers, not the master,
because it requires access to authentication information.
Thus, the master can pick any worker using a load
balance algorithm (detailed in Section~\ref{sec:lb}),
and the selected worker will then process the request according
to the instantiation strategy.
After consulting the authentication information, this worker will redirect 
the client to a specific Browser URL.   The virtual browser corresponding
to that URL may be located in another worker process.

When a worker process receives a Browser URL request, it will locate the
corresponding virtual browser and responds with an HTML document that contains
information to bootstrap the client engine. 
The client engine will create a WebSocket connection to establish an RPC channel to
the worker process.
First, the client engine sends a WebSocket handshake request to initiate the
WebSocket connection.
The handshake request URL contains the associated \appins id and virtual browser
id so the master can find the corresponding worker for this request.
After the worker sends back the handshake response, the connection
between the worker and the reverse proxy that performed the handshake, 
as well as the connection between the reverse proxy and the user remains open. 
The reverse proxy will relay all subsequent WebSocket messages
without parsing them and without requiring repeated calls to the master
to obtain forwarding information.

As the client engine renders the client-side view of the page, it may trigger
requests for auxiliary resources such as images or spreadsheets. 
These requests will contain the \appins{} id in the URL, which the master
uses to forward those requests to the appropriate worker.

%If any exception happens, for example, the user sends a Browser URL with no
%corresponding virtual browser in the system, the system will reject the
%request with an error message.

In this design, the reverse proxies ask the master for the dispatch decision
for every HTTP request.  However, HTTP requests are required only when users
reconnect to virtual browsers - most of the actual interaction with a virtual
browser is performed using RPC messages carried over WebSocket connections.
Thus, the overhead of inter-process communication between the reverse proxies and
the master to obtain forwarding information affects only a small portion of the network traffic. 

We also provide an option to embed a reverse proxy instance inside the master process.
If the system is configured with one single embedded reverse proxy,
reverse proxy and master can communicate directly.
However, in this mode, the system can support fewer concurrent users than 
when using multiple reverse proxies.

\section{Load Balancing}
\label{sec:lb}

The load balancing algorithm is invoked in two scenarios:
First, when the user requests an \emph{Application URL},
the master needs to find a worker to handle this request.
Second, it is invoked when the system is about to create an \appins{}.
Although such action can originate in any worker,
the load balancing algorithm is performed by the master.

For other user requests the routing is determined by the \appins{}-to-worker map
so there is no need for load balancing.
In particular, the creation of virtual browsers is not subject to load balancing.
Virtual browsers have to be placed in the same worker that hosts its \appins{}.

We support two load balancing strategies: first, the master can assign the
load to workers in a simple round-robin fashion. However, since \appins{}s may
vary widely in terms of the actual cost they impose on a worker and \appins{}s
can be terminated, the round-robin assignment works well only for cases in 
which resource use is uniformly distributed.
We also implemented a load-based scheme in which
workers periodically report a measure of current load to the master. The
master will select the worker with the lowest load when making load balancing decisions.
We have found the amount of heap memory that is currently in use a good measure
of a worker's momentary load.

In the load-based mode, the master's knowledge of a worker's load is not
always up-to-date as the worker's load can change before the master receives the
next report from the worker. We have found that this can lead to very unbalanced load
distributions. For example, when the system is creating a burst of \appins{}s,
they are all assigned to the same worker that has the lowest load at that
moment and this worker ends up hosting a disproportionate load.  To mitigate
this issue,  after the load balancing algorithm selects a worker, the
algorithm makes a projection of the worker's load after accepting the new
load. The projected value is used as the worker's load value  until the master
sees the worker's next report.  We have found it unnecessary to exactly 
predict the amount of incremental load as long as we do not significantly 
underpredict.  Based on our evaluation, a virtual
browser in a non-trivial application takes about 6M.  The master projects a
worker's load increase by 10M for every new \appins assignment assuming every
\appins will create 1 or 2 virtual browsers.  For most cases, the master
overestimates the actual load increase. It is not a problem because the master
corrects its estimate as soon as it sees the worker's next report. 
% ???
%In our experience, even under bursts of new requests the load distribution among the
%workers does not vary greatly.

\section{Master Implementation}
\label{sec:masterimpl}

This section describes the main modules in the master and how they interact
with worker processes.

\begin{description}
\item[Application Manager] \hfill \\
The Application Manager is responsible for maintaining the state of applications. 
It reads application bundles (discussed in Section~\ref{sec:deploymodel}) and
initializes the data structures used to represent applications.

\item[Worker Manager] \hfill \\
The Worker Manager is responsible for the request dispatch
and the load balancing algorithm.

\item[Reverse Proxy Manager] \hfill \\
The Reverse Proxy Manager starts multiple reverse proxy processes as child
processes of the master and handles the communication between the master and
the reverse proxies.
% the queries are sent from pipe, called ipc channel in node.js
% https://github.com/joyent/node/blob/master/lib/child_process.js
\end{description}

After initialization, the master exposes the \emph{Application Manager} and
\emph{Worker Manager} objects to the workers via nodermi's \code{registerObj} method
(discussed in Chapter~\ref{ch:rmi}).

The \emph{Application Manager} includes methods related to application management,
such as listing applications, creating new applications, removing applications,
etc.  The applications are represented by application objects. An application
object has methods to manage the internal state of an application, which include
methods to change the application's authentication policy, register a new \appins, 
remove an \appins, etc.  Since the \emph{Application Manager} is registered in nodermi,
workers can obtain remote references to it; the application objects returned by its
methods are also automatically represented as nodermi remote references.
The master's Application Manager coordinates with the Application Manager
objects in each worker as described in Section~\ref{sec:worker}.

The \emph{Worker Manager} contains methods for workers to register the URL at which
they can be reached and report their load.  It maintains a table of \appins{} id to
worker URL for dispatching requests.  This table is updated
every time a \appins{} is registered or removed from the \emph{Application
Manager}.

\section{Worker Implementation}
\label{sec:worker}

This section describes the implementation of worker processes.
The key components of a worker process include:

\begin{description}

\item[Application Manager] Manages applications' metadata, application instantiation
logic, local \appins{}s
and local virtual browsers. It provides methods to lookup local \appins{}s and virtual
browsers by ids. It also processes incoming HTTP requests.

Workers pass a reference to the \emph{Application Manager} and application objects to
the master's \emph{Application Manager} via remote method invocation.  The
master uses remote references to these worker
objects to push application-related changes to the  workers.  For instance,
the master calls  a worker's \code{addApplication} method remotely to
push new applications to that worker and remove an application from that worker
by calling the worker's \code{removeApplication} method remotely.

\item[Session Manager] 
Manages HTTP sessions and users' login states. The sessions
are stored in a database server that is accessible for all workers. 
The users' login states are stored in session properties 
as discussed in Section~\ref{sec:auth}.


\item[HTTP Server] Listens for HTTP requests from reverse proxies and dispatches 
    the requests to the \emph{Application Manager}. 

\item[Permission Manager] 
Manages users' permissions to applications, \appins{}s and virtual browsers.
If an application enables authentication, it can call the \emph{Permission
Manager} to grant or revoke access to  \appins{}s and virtual
browsers for specific users. 

The system will reject HTTP requests that violate
the permission settings in the  \emph{Permission Manager}. For instance, if a
user requests a \emph{Browser URL} of a browser he does not have permission to
connect, this request will be rejected. 

If the application does not set
customized permissions, the \emph{Permission Manager} enforces a default
permission policy which is useful for most cases.  For example, a user
cannot access the virtual browsers that were created by other users, only
those created by themselves.
To go beyond this default policy,
the landing pages of \emph{multiInstance} and \emph{singleBrowserPerUser}
applications include interfaces for users to manage the permission settings of
their \appins{}s and virtual browsers.

\end{description}


% For each worker, the system administrator needs to specify a hostname/port
% pair the worker listens for HTTP requests,  the master's nodermi instance's
% hostname/port, and a hostname/port for its own nodermi instance in a
% configuration file. To ease the deployment effort, we provide a tool that can
% generate multiple worker configuration files. Based on the information in the
% configuration file, the worker creates a HTTP server and a nodermi instance.

After creating its internal components, the worker process will try to obtain
remote references to the master's \emph{Application Manager} and \emph{Worker
Manager} via nodermi, then it fetches all the applications' metadata and
registers itself to the master by remote method invocation. If the master is
not running, the worker will keep on retrying until these remote references
are obtained.

% should above paragraph be moved closer to earlier discussion about
% communication with master?

When a worker receives an HTTP request, it parses the request to extract
\appins id, virtual browser id and retrieves associated user information from
session.

If the request does not have an \appins id, the worker either allocates a
virtual browser in the system or redirects the user to a landing page.  The
\appins{} associated with the virtual browser could be located at the worker itself or
at another worker.  If an \appins{} needs to be created, the worker will ask
the master to  find a worker to create the new \appins{}, a virtual browser
will also be created in the new \appins{}.  Because user interactions are
 handled by virtual browsers, the worker then will redirect the user
to the virtual browser's URL. 

If the request contains an \appins id but does not have a virtual browser id, 
the worker either allocates a virtual browser for the request or
redirect the request to a landing page.
In the first case, the worker either 
picks an existing virtual browser in the \appins  or creates a new one based on
the application instantiation strategy, then the worker sends back a redirect
response with  the virtual browser's \emph{Browser URL}.

If the request has a virtual browser id, the worker finds the matching local
virtual browser to handle the request. For \emph{Browser URL} requests, the
worker sends back the initial  HTML document to bootstrap the client engine.
For resource requests, the virtual browser will retrieve the corresponding
resource files either from the local file system or from other servers based 
on their URL, then send back the content.
For WebSocket handshake requests, the worker will send back a handshake
response message and add the WebSocket connection to the virtual browser,
which keeps track of connected clients.
The subsequent WebSocket messages will be directly handled by RPC methods
of the virtual browser.

\input{api}
