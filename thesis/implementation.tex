\chapter{Implementation}
\label{ch:impl}
\markright{Implementation}

\newarchitectureoverview{}

Since virtual browsers occupy most of the system resource, the new
distributed design spread the virtual browsers to multiple processes
to improve the system's scalability.
As shown in Figure~\ref{fig:cb2arch}, \cbtwo consists of a
single master process, multiple reverse proxies, and multiple worker
processes. All processes communicate via standard TCP/IP sockets, so they can
be located on a shared multiprocessor machine or in a cluster. The workers
host application instances and virtual browsers. The master is responsible for
the request dispatch logic which decides how to distribute the client load to
workers. The actual dispatching is implemented by the reverse proxies, they
forward users' requests to workers and copy workers' responses back to users.
The reverse proxy processes are bound to the socket that accepts client
requests, allowing the OS to distribute pending client connections in a round-
robin fashion. The reverse proxy can relay both HTTP requests/responses as
well as the bidirectional WebSocket protocol after the connection has been
upgraded.  Once established, the majority of traffic will be WebSocket
messages for which there is relatively little per-message overhead.  We
implemented the proxy using the \nodejs{} module node-http-proxy~\cite{nodeproxy}.


% The master process is a single point of failure,
% but it is light weight and does less computation,
% so it is less likely to fail in practice.

% discuss the user request, message flow

\section{Request Dispatch}
\label{sec:reqdis}
% ---- motivation, use cases here
% ---- make it clear that after dispatch, the messages websocket
A user can access a \cb{} application using an URL of the following types:

\begin{description}

\item[Application URL] \label{itm:appurl} \hfill \\
Format: \url{http://example.com/[app]}, \code{[app]} represents an
application's mount point.   For example, if an application's mount point is
\emph{chat},  then its Application URL is \url{http://example.com/chat}.


\item[\appins{} URL] \label{itm:appinsurl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]},
\code{[appInstanceId]} represents an \appins{}'s id.  For example, if an
\appins{}'s id is \emph{appins1} and its application's mount point is
\emph{chat}, then its \appins{} URL is
\url{http://example.com/chat/a/appins1}.


\item[Browser URL] \label{itm:vburl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]/b/[browserId]},
\code{[browserId]} represents a virtual browser's id. For example, if a
virtual browser's id is \emph{browser1} and its \appins{} is the application
instance \emph{appins1} in the previous example, then the virtual browser's
Browser URL is \url{http://example.com/chat/a/appins1/b/browser1}.

\end{description}
% -----scenario of these URLs, when low load, the reverse proxy could be embedded

For a \emph{multiInstance} application, the \emph{Application URL} takes the
user to a landing page listing all his \appins{}s and virtual browsers
including those are shared with other users. The user can share his \appins{}s
to someone else on that page and the system will send the \emph{\appins{}
URL}s to that user. When a user requests \emph{\appins{} URL} that he has
rights to access, the system will either create a new virtual browser for him
or redirect him to his existing virtual browser in the \appins{}. The
\emph{Browser URL} is used to connect to a specific virtual browser. The user
can bookmark \emph{\appins{} URL}s and \emph{Browser URL}s for future visits.

For a \emph{singleAppInstance} application (application instantiation
strategies  are discussed in Section~\ref{sec:appinstantiation}), the system
creates only one virtual browser for all users. When the user requests the
\emph{Application URL}, the system redirects the user with the only virtual
browser's \emph{Browser URL}. The user could bookmark the \emph{Browser URL}
and visit the application with that URL without redirect. The \emph{\appins
URL} is not exposed to the users in a \emph{singleAppInstance} application
because there is no use case of sharing \appins. If the user requests with the
only virtual browser's \emph{\appins URL}, the system will send back a
redirect response with the \emph{Browser URL}.



When the user requests
 an application URL, the application will allocate a new virtual browser or
find an existing virtual browser for that user, and sends back the user a
redirect with the Browser URL of that virtual browser. The \appins URLs are
used to connect to virtual browsers in specified \appins{}s. For example, in a
chat room application that models a chat rooms as an \appins{} and a user's
chat window in a particular chat room  as a virtual browser, user A could
invite user B to join a chat room by share the chat room's \appins URL, when
the user B requests for the \appins URL for the first time, a new virtual
browser will be allocated in the \appins for user B, then the system will send
a redirect to user B with the virtual browser's Browser URL. User B's
subsequent requests to the \appins URL would be directed to the Browser URL of
the virtual browser created earlier. The Browser URLs are used to connect to
specified virtual browsers.



To preserve the semantics of \appins (discussed in Section~\ref{sec:appins})
that virtual browsers in an \appins could directly share data structure, each
\appins and its virtual browsers must be allocated in the same worker process
as emphasized in Figure~\ref{fig:appidhierarchy}. The master keeps a lookup
table of \appins id to worker process mappings.  When the request URL contains
an \appins id,  the master could find the corresponding worker right away.

When the client sends a HTTP request to the system, a reverse proxy process
will accept this HTTP request and ask the master where to dispatch this
request. If \appins id is in the request URL, the master would find a worker
via the lookup table. Otherwise, the master would find a worker using load
balance algorithm detailed in Section~\ref{sec:lb}. The reverse proxy then
forwards the request to the worker process. If the request URL does not
contain virtual browser id, the worker process would allocate a new virtual
browser or find an existing virtual browser in the system and sends back a
redirect response with the virtual browser's Browser URL. Upon receiving the
redirect response, the user will send another HTTP request with the Browser
URL.

When a worker process receives a Browser URL request, it will locate the
corresponding virtual browser and responds a HTML document that contains
information to bootstrap the client engine. The client engine will create a
WebSocket connection to synchronize DOM nodes. First, the client engine sends
a WebSocket handshake request which is a HTTP request to initiate the
WebSocket connection, the \appins id is embedded in the handshake request URL.
Like we discussed, a reverse proxy will receive this request and forward it to
the worker. After the worker send back the handshake response, the connection
between the worker and the reverse proxy, and the connection between the
reverse proxy and the user remains open. Subsequent WebSocket messages will go
through these two opened connections to forward user events and synchronize
DOM states for the specific virtual browser. The reverse proxy will just copy
the WebSocket messages back and forth without parsing them.

If any exception happens, for example, the user sends a Browser URL with no
corresponding virtual browser in the system, the system will reject the
request with an error message.

After client engine establishes WebSocket connections, the client could send
additional HTTP requests to fetch resources such as stylesheets, images, etc.
Since the URLs for these resources contains the current \appins id and virtual
browser id, these request could be dispatched to the right worker and  served
without redirect.

In this design, the reverse proxies ask the master for the dispatch decision
for every HTTP request.  Since the majority of the system's network traffic
are WebSocket messages and they do not need to invoke dispatch logic,  this
overhead of inter-process communication between the master and the reverse
proxies   only affects a small portion of the network traffic. We also provide
an option to embed a reverse proxy instance inside the master process. The
embedded reverse proxy  communicates with the master via method calls thus no
inter-process overhead is introduced.

\section{Load Balancing}
\label{sec:lb}

% ------- explain when lb decision is been made, don't introduce new term
When the master receives a HTTP request that does not have an \appins id,
the master does not know if the request would result in creating a new \appins
or be handled by an existing \appins,
it needs to find a worker process to handle it using application specific
logic.
When a new \appins{} is going to be created,
the system needs to select a worker process to place it.
In these two cases, load balancing algorithm is invoked to make the load
of the system more evenly distributed among workers.
For other cases, there is no need to call the load balancing algorithm
because the load is already fixed.
For instance,
if a request contains \appins id, the master dispatches the request to
the worker that hosts the \appins via its lookup table and
the master cannot dispatch the request elsewhere.
If the system needs to create a new virtual browser,
it could only be created in the same worker process as its \appins{}.



We support two load balancing strategies: first, the master can assign the
load to workers in a simple round-robin fashion. However, since \appins{}s may
vary widely in terms of the actual cost they impose on a worker and \appins{}s
can be terminated,  the round-robin assignment only works well for simple use
cases like benchmarking. We also implemented a load-based scheme in which
workers periodically report a measure of current load to the master. The
master will select the worker with the lowest load when placing new load.  We
have found the amount of heap memory that is currently in use a good measure
of a worker's  momentary load.

In the load-based mode,  the worker's load could change during the interval
between the worker's updates, and the master's knowledge is not updated. This
could lead to problematic load distribution. For example,  when the system is
creating a burst of \appins{}s, they could all be assigned to the same worker
that has the lowest load at that moment.  This could cause extremely uneven
load distribution. To mitigate this issue,  after the load balancing algorithm
selects a worker, the algorithm makes a projection of the worker's load. Based
on our evaluation, a virtual browser in a non-trivial application takes about
6M.  We increase a worker's load by 10M for every new \appins assignment
assuming each \appins will have 1 or 2  virtual browsers. Although this
estimate is not accurate, the worker's load will be fixed upon receiving next
load update. In this way, even under bursts of new requests,  the load
distribution between the workers would not vary greatly.



\section{Master Implementation}

When the master process starts up, it initiates the following modules:

\begin{description}
\item[Application Manager] \hfill \\
Application Manager is responsible to maintain the state of applications. It
reads the application bundles (discussed in Section~\ref{sec:deploymodel}) and
initiate data structures to represent applications.

\item[Worker Manager] \hfill \\
Worker manager is responsible for the request dispatch 
and the load balance algorithm (detailed in Section~\ref{sec:lb}).

\item[Reverse Proxy Manager] \hfill \\
Reverse proxy manager starts multiple reverse proxy processes as child
processes of the master and handles queries from them.
% the queries are sent from pipe, called ipc channel in node.js
% https://github.com/joyent/node/blob/master/lib/child_process.js
\end{description}

After initiation, the master exposes \emph{Application Manager} and
\emph{Worker Manager} to the workers via nodermi's \code{registerObj}  method
(discussed in Chapter~\ref{ch:rmi}).  

The \emph{Application Manager} has
methods to list all applications, to create a new application, to  remove an
application, etc. Each application object has methods to maintain the internal
state of the application, such as change the application's authentication
policy, register a new \appins, remove an \appins, etc. The worker invoke
these methods remotely to obtain metadata of all applications, register an
\appins, etc. The worker also register its own \emph{Application Manager}  and
application objects to the master's \emph{Application Manager}  via remote
method invocation. The master \emph{Application Manager}  uses stubs to these
worker objects to push changes to the  workers. For instance, the master uses
stubs to the worker's \emph{Application Manager} to push new application to
that worker and remove an application from that worker.

The \emph{Worker Manager} contains methods for worker to register its HTTP
hostname/port and report its load. It also maintains a table of \appins{} id
to worker HTTP hostname/port. This table is updated every time a \appins{}
is registered or removed from the \emph{Application Manager}. 




\section{Worker Implementation}
\label{sec:worker}

When a worker process starts up, it first reads a configuration file that
specifies the port it is going to listen for HTTP requests,  the hostname/port
pair of the master process's nodermi instance   and the hostname/port pair for
its own nodermi instance. After initializing, the worker process obtains
remote references to the master's \emph{Application Manager} and \emph{Worker
Manager} via nodermi, then  it fetches all the applications' metadata and
registers itself to the master by invoking methods of these remote references.
If the master is not running, the worker will keep on retrying until the
remote references are obtained.

% ------ mapping bid to browser is in worker, make it clear, use html5 history
% to change url in location bar 
The worker process maintains the mappings of \appins{} id to its local
\appins{}s and browser id to its local virtual browsers.
When a worker receives a HTTP request, it parses the request to extract
\appins id, virtual browser id and user information. If the request does not
have an \appins id, the worker would find an existing virtual browser in the
system or tell the master to create a new one  based on the application
instantiation strategy discussed in Section~\ref{sec:appinstantiation}. After
that, the worker sends back a redirect response with the virtual browser's
\emph{Browser URL}. If the request has an \appins id, the worker first check
if the id matches any local \appins and rejects the request if the check
fails. If the request does not have a virtual browser id, the worker either
picks an existing virtual browser in the \appins  or create a new one based on
the application instantiation strategy, then the worker sends back a redirect
response with  the virtual browser's \emph{Browser URL}. If the request has a
virtual browser id and it matches a virtual browser in the \appins, the worker
processes the request based on the type of the request: For \emph{Browser URL}
requests, the worker sends back the initial  HTML document; For resource
requests, the virtual browser will read the corresponding local resource files
from file system or from Internet, and send back the content. For WebSocket
handshake requests, the worker would send back a handshake response message
and add the connection to the virtual browser.


If the application requires authorization in the configuration, the
worker would also check if the user has the permission to access the \appins
or virtual browser specified in the request. The framework has a default
permission policy that is useful for most cases. For example, by default the
user could only access the virtual browsers he creates. We also provide a
default web interface for users to manage the permissions of their \appins{}s
and virtual browsers. The programmer could also explicitly manage user
permissions in application code.

\input{api}
