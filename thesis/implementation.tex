\chapter{Implementation}
\label{ch:impl}
\markright{Implementation}

\newarchitectureoverview{}

Since virtual browsers occupy most of the system resource, the new
distributed design spread the virtual browsers to multiple processes
to improve the system's scalability.
As shown in Figure~\ref{fig:cb2arch}, \cbtwo consists of a
single master process, multiple reverse proxies, and multiple worker
processes. All processes communicate via standard TCP/IP sockets, so they can
be located on a shared multiprocessor machine or in a cluster. The workers
host application instances and virtual browsers. The master is responsible for
the request dispatch logic which decides how to distribute the client load to
workers. The actual dispatching is implemented by the reverse proxies, they
forward users' requests to workers and copy workers' responses back to users.
The reverse proxy processes are bound to the socket that accepts client
requests, allowing the OS to distribute pending client connections in a round-
robin fashion.
The reverse proxy can relay both HTTP requests/responses as
well as the bidirectional WebSocket protocol (see Section~\ref{sec:nodepackage}).
Once the client established WebSocket connection with
the server side, the majority of traffic will be WebSocket
messages for which there is relatively little per-message overhead.


% The master process is a single point of failure,
% but it is light weight and does less computation,
% so it is less likely to fail in practice.

% discuss the user request, message flow

\section{Request Dispatch}
\label{sec:reqdis}
% ---- motivation, use cases here
% ---- make it clear that after dispatch, the messages websocket

The system exposes three types of URLs for the users to access \cb applications.
The format of these URLs are as follows:

\begin{description}

\item[Application URL] \label{itm:appurl} \hfill \\
Format: \url{http://example.com/[app]}, \code{[app]} represents an
application's mount point.   For example, if an application's mount point is
\emph{chat},  then its Application URL is \url{http://example.com/chat}.


\item[\appins{} URL] \label{itm:appinsurl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]},
\code{[appInstanceId]} represents an \appins{}'s id.  For example, if an
\appins{}'s id is \emph{appins1} and its application's mount point is
\emph{chat}, then its \appins{} URL is
\url{http://example.com/chat/a/appins1}.


\item[Browser URL] \label{itm:vburl} \hfill \\
Format: \url{http://example.com/[app]/a/[appInstanceId]/b/[browserId]},
\code{[browserId]} represents a virtual browser's id. For example, if a
virtual browser's id is \emph{browser1} and its \appins{} id is 
 \emph{appins1} and its application's mount point is \emph{chat},
  then the virtual browser's
Browser URL is \url{http://example.com/chat/a/appins1/b/browser1}.

\end{description}
% -----scenario of these URLs, when low load, the reverse proxy could be embedded

For all application instantiation strategies (discussed in
Section~\ref{sec:appinstantiation}), 
the user may prefer to access the application use 
\emph{Application URL}
because it is easy to remember and
it leads to a default view where user can navigate to other views (if he has any).
From the user's point of view,
the \emph{Application URL} is similar to the homepage URL in a traditional web application.
For \emph{singleAppInstance}   and \emph{singleInstancePerUser}
applications where the user can access only one   virtual browser, the system
redirects the user to that virtual browser when handling \emph{Application
URL}. 
For \emph{singleBrowserPerUser} and \emph{multiInstance} applications, the
system will present the user a landing page listing all his \appins{}s and
virtual browsers when handling \emph{Application URL}. From there the user can
access any of his \appins{}.

\emph{\appins{} URL} is used for joining  a specific \appins{}.  
It is not
directly exposed to the end users in \emph{singleAppInstance}   and
\emph{singleInstancePerUser} applications because there is only one \appins{}
for a given user. 
For \emph{singleBrowserPerUser} applications where each user
can create only  one virtual browser for a given \appins{}, the system directs
the user to his own virtual browser in the specified \appins{} when handling
\emph{\appins{} URL}. 
For \emph{multiInstance}
applications, it is the user's responsibility to decide whether joining an
existing virtual browser or create a new one,
 the system will present the user the landing page to make that decision. 
For \emph{singleBrowserPerUser}
and \emph{multiInstance} applications, users can share an \appins{} with
others by sharing its \emph{\appins{} URL}.

\emph{Browser URL} is for joining a specific virtual browser. The user can
bookmark a \emph{Browser URL} so he can revisit that specific  virtual browser
in the future. The user can also share a virtual browser with other people by
sharing its \emph{Browser URL}.

The semantics of \appins (discussed in Section~\ref{sec:deploymodel})
requires an \appins{}'s virtual browsers be able to reference shared data structure.
In \cbtwo, the system keeps every \appins and its virtual browsers in the same worker process.
Thus the routing for \emph{\appins{} URL}s and \emph{Browser URL}s is fixed to 
the workers that host the associated \appins{}s.
For \emph{Application URL}s, the system need first allocate an \appins{} and virtual
browser to handle the request according to the instantiation strategy, and then
redirect the request with the virtual browser's URL.



When the client sends a HTTP request to the system, a reverse proxy process
will accept this HTTP request and ask the master where to dispatch this
request. 

If the request URL is a \emph{Browser URL} or \emph{\appins URL}, 
the master extracts \appins id from the URL and returns the associated
worker via a \appins id to worker lookup table.
This lookup table is updated every time an \appins{} is created or removed.
For an \emph{\appins URL} request, the worker will continue to find the associated
virtual browser for the user and send back a redirect with the virtual browser's URL.

If the request URL is an \emph{Application URL}, 
the system's behavior varies according to the application's instantiation strategy.
For example, for a \emph{singleInstancePerUser} application,
the system can either create a new \appins{} for the user if the user does not have an
\appins or use the user's existing \appins{} if otherwise.
Since the master does not have application specific logic,
the master first picks a worker using load
balance algorithm (detailed in Section~\ref{sec:lb}) to handle the request
temporarily, and the selected worker will then process the request according
to the instantiation strategy.
It is not necessary for the selected worker to serve this request because
the \appins{} that the worker finds for this request might be in another 
worker.
After the selected worker finds the \appins{} and virtual browser for this
request, it will send a redirect request with the virtual browser's URL
back to the user.

When a worker process receives a Browser URL request, it will locate the
corresponding virtual browser and responds a HTML document that contains
information to bootstrap the client engine. 
The client engine will create a
WebSocket connection to synchronize DOM nodes. 
First, the client engine sends
a WebSocket handshake request to initiate the
WebSocket connection.
The handshake request URL contains the associated \appins id and virtual browser
id so
the master can find the corresponding worker for this request.
After the worker sends back handshake response, the connection
between the worker and the reverse proxy that receives the handshake
, and the connection between the
reverse proxy and the user remains open. The reverse proxy will just copy
the subsequent WebSocket messages back and forth without parsing them and
asking the master for destination.

After the WebSocket connection establishes, the subsequent requests such as
requests for resource files all have \appins{} id in the URLs or in the referrer
header fields, the master can find destination for these requests directly. 

If any exception happens, for example, the user sends a Browser URL with no
corresponding virtual browser in the system, the system will reject the
request with an error message.

In this design, the reverse proxies ask the master for the dispatch decision
for every HTTP request.  Since the majority of the system's network traffic
are WebSocket messages and they do not trigger dispatch logic,  this
overhead of inter-process communication between the master and the reverse
proxies   only affects a small portion of the network traffic. 
We also provide
an option to embed a reverse proxy instance inside the master process.
If the system is configured with one single embedded reverse proxy,
the overhead of inter-process communication between the master and the reverse
proxy is eliminated entirely.
However, in this mode the system has a lower capacity of supporting concurrent users
comparing to using multiple reverse proxies.

\section{Load Balancing}
\label{sec:lb}

The load balancing algorithm is invoked in two scenarios:
First, when the user requests an \emph{Application URL},
the master needs to find a worker to handle this request.
As discussed before, for other user requests the routing is already fixed
so there is no need for load balancing.
Second, when the system is about to create a \appins{}.
In this case, the master has the flexibility to choose a worker.
When the system creates a virtual browser, the virtual browser has
to be placed in the same worker that hosts its \appins{}, the system
cannot place it somewhere else for the load balancing purpose.


We support two load balancing strategies: first, the master can assign the
load to workers in a simple round-robin fashion. However, since \appins{}s may
vary widely in terms of the actual cost they impose on a worker and \appins{}s
can be terminated,  the round-robin assignment only works well for simple use
cases like benchmarking. We also implemented a load-based scheme in which
workers periodically report a measure of current load to the master. The
master will select the worker with the lowest load when placing new load.  We
have found the amount of heap memory that is currently in use a good measure
of a worker's  momentary load.

In the load-based mode, the master's knowledge of a worker's load is not
always up-to-date as the worker's load can change before the master sees the
next report message from the worker. This can lead to problematic load
distribution. For example, when the system is creating a burst of \appins{}s,
they are all assigned to the same worker that has the lowest load at that
moment and the worker ends up hosting a disproportional load.  To mitigate
this issue,  after the load balancing algorithm selects a worker, the
algorithm makes a projection of the worker's load after accepting the new
load. The projected value is used as the worker's load value  until the master
sees the worker's new report message. Based on our evaluation, a virtual
browser in a non-trivial application takes about 6M.  The master projects a
worker's load increase by 10M for every new \appins assignment assuming every
\appins will create 1 or 2  virtual browsers.  For most cases, the master
overestimates the actual load increase. It is not a problem because
overestimation helps spread load among multiple  workers and the master will
fix its estimation when it sees the worker's report message. In our
experience, even under bursts of new requests the load distribution among the
workers does not vary greatly.



\section{Master Implementation}

When the master process starts up, it initiates the following modules:

\begin{description}
\item[Application Manager] \hfill \\
Application Manager is responsible to maintain the state of applications. It
reads the application bundles (discussed in Section~\ref{sec:deploymodel}) and
initiate data structures to represent applications.

\item[Worker Manager] \hfill \\
Worker manager is responsible for the request dispatch
and the load balance algorithm (detailed in Section~\ref{sec:lb}).

\item[Reverse Proxy Manager] \hfill \\
Reverse proxy manager starts multiple reverse proxy processes as child
processes of the master and handles queries from them.
% the queries are sent from pipe, called ipc channel in node.js
% https://github.com/joyent/node/blob/master/lib/child_process.js
\end{description}

After initiation, the master exposes \emph{Application Manager} and
\emph{Worker Manager} to the workers via nodermi's \code{registerObj}  method
(discussed in Chapter~\ref{ch:rmi}).

The \emph{Application Manager} has
methods to list all applications, to create a new application, to  remove an
application, etc. Each application object has methods to maintain the internal
state of the application, such as change the application's authentication
policy, register a new \appins, remove an \appins, etc. The worker invoke
these methods remotely to obtain metadata of all applications, register an
\appins, etc. The worker also register its own \emph{Application Manager}  and
application objects to the master's \emph{Application Manager}  via remote
method invocation. The master \emph{Application Manager}  uses stubs to these
worker objects to push changes to the  workers. For instance, the master uses
stubs to the worker's \emph{Application Manager} to push new application to
that worker and remove an application from that worker.

The \emph{Worker Manager} contains methods for worker to register its HTTP
hostname/port and report its load. It also maintains a table of \appins{} id
to worker HTTP hostname/port. This table is updated every time a \appins{}
is registered or removed from the \emph{Application Manager}.




\section{Worker Implementation}
\label{sec:worker}

When a worker process starts up, it first reads a configuration file that
specifies the port it is going to listen for HTTP requests,  the hostname/port
pair of the master process's nodermi instance   and the hostname/port pair for
its own nodermi instance. After initializing, the worker process obtains
remote references to the master's \emph{Application Manager} and \emph{Worker
Manager} via nodermi, then  it fetches all the applications' metadata and
registers itself to the master by invoking methods of these remote references.
If the master is not running, the worker will keep on retrying until the
remote references are obtained.

% ------ mapping bid to browser is in worker, make it clear, use html5 history
% to change url in location bar
The worker process maintains the mappings of \appins{} id to its local
\appins{}s and browser id to its local virtual browsers.
When a worker receives a HTTP request, it parses the request to extract
\appins id, virtual browser id and user information. If the request does not
have an \appins id, the worker would find an existing virtual browser in the
system or tell the master to create a new one  based on the application
instantiation strategy discussed in Section~\ref{sec:appinstantiation}. After
that, the worker sends back a redirect response with the virtual browser's
\emph{Browser URL}. If the request has an \appins id, the worker first check
if the id matches any local \appins and rejects the request if the check
fails. If the request does not have a virtual browser id, the worker either
picks an existing virtual browser in the \appins  or create a new one based on
the application instantiation strategy, then the worker sends back a redirect
response with  the virtual browser's \emph{Browser URL}. If the request has a
virtual browser id and it matches a virtual browser in the \appins, the worker
processes the request based on the type of the request: For \emph{Browser URL}
requests, the worker sends back the initial  HTML document; For resource
requests, the virtual browser will read the corresponding local resource files
from file system or from Internet, and send back the content. For WebSocket
handshake requests, the worker would send back a handshake response message
and add the connection to the virtual browser.


If the application requires authorization in the configuration, the
worker would also check if the user has the permission to access the \appins
or virtual browser specified in the request. The framework has a default
permission policy that is useful for most cases. For example, by default the
user could only access the virtual browsers he creates. We also provide a
default web interface for users to manage the permissions of their \appins{}s
and virtual browsers. The programmer could also explicitly manage user
permissions in application code.

\input{api}
