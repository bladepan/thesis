\chapter{Introduction}
\markright{Introduction}

\section{Motivation}

Most newly developed applications that provide a user interface to end users 
are web-based.  Modern browsers provide powerful and expressive user interface 
elements, allowing for rich applications, and the use of a networked
platform simplifies the distribution of these applications.  As a result,
researchers and practitioners alike have devoted a great deal of attention to
how to architect frameworks on this platform, which is characterized by the
use of the stateless HTTP protocol to transfer HTML-based user interface 
descriptions to the client along with JavaScript code, which in turn 
implements interactivity and communication with the application's backend tiers.

In many recently developed frameworks, much of the presentation logic of these applications
executes within the client's browser.  User input triggers events
which result in information being sent to a server and subsequent user interface updates.
Such updates are implemented as modifications to an in-memory tree-based
representation of the UI (the so-called document object model, or DOM), which
is then rendered by the browser's layout and rendering engine so the user can see it.
However, the state of the DOM is ephemeral in this model: when a user visits 
the same application later from the same or another device, or simply reloads the page, the state of the
DOM must be recreated from scratch.  In most existing applications, this 
reconstruction is done in an rudimentary and incomplete way, because
application programmers typically store only application state, and little 
or no presentation state in a manner that persists across visits.
As a result, many web applications do not truly feel like persistent,
``in-cloud'' applications to which a user can connect and disconnect at will.
By contrast, users are accustomed to features such as Apple's Continuity\cite{apple-continuity}
that allows them to switch between devices while preserving not only 
essential data, but enough of the applications' view to create the appearance
of seamlessly picking up from where they left off.

\cb{}~\cite{mcdaniel2012cloudbrowser} is a server-centric web framework 
that keeps the state of the HTML document in memory 
on the server in a way that is persistent across visits.
In this model, presentation state is kept in virtual browsers whose life
cycle is decoupled from the user's connection state.  When a user is connected,
a client engine mirrors the state of the virtual browser in the actual browser which
renders the user interface the user is looking at.  Any events triggered by the
user are sent to the virtual browser, dispatched there, and any updates
are reflected in the client's mirror.  This idea is reminiscent of 
``thin client'' designs used in cloud-based virtual desktop offerings,
but with the key difference that in this proposed design the presentation state
that is kept in a virtual browser is restricted to what can be represented at the
abstract DOM level; no flow layout or rendering is performed by the virtual browser on the 
server.

This model entails additional potential benefits: since only framework code runs in
the client engine, the application code running on the server does not need
to handle any client/server communication and can be written in an event-based
style similar to that used by desktop user interface frameworks.
Since the virtual browser has the same JavaScript execution capabilities as a
standard browser, emerging model-view-controller (MVC) frameworks such as 
AngularJS~\cite{hevery2009angular} can be directly used, further simplifying application development.
More side benefits include: a lighter weight client engine that can load faster,
a resulting application that is potentially more secure since no direct access to
application data needs to be exposed, the ability to co-browse by broadcasting
the virtual browser state to multiple clients.

The original implementation of \cb{} is single threaded and
only supports deployment on one process.
It could not scale horizontally by adding more processors or more machines
to increase the system's capacity.
To enable \cb{} to host large scale web applications,
we designed and implemented \cbtwo which could distribute and manage
virtual browsers on CPU cores of a multiprocessor machine or on a cluster of machines.
We have implemented a number of sample and benchmark
applications and profiled them to better understand the intrinsic and extrinsic
limitations of this design.

% benchmark results

\webscaleoutfig{}

\section{Core Contributions}

We have implemented \cbtwo that distributes and manages virtual browsers
to multiple processes.
We managed to make this upgrade transparent for application developers.
Most of the existing applications could automatically scale to 
multiple processors without modifying the code.
We need to modify other applications because we updated part of
the \cb{} API that these applications depend on,
not because these applications need to be aware that they might run on
multiple processes.
\cb{} applications are still developed in a way that as if they are run in
a web browser that users could remotely connect to.

There are several challenges to achieve this transparent upgrade.
First, \cb{} is stateful in nature, 
the application state and UI representation resides in virtual browsers,
so the users' requests have to be directed to the corresponding virtual browser
to make things work.
It is trivial if all virtual browsers are in the same process.
In a multiple process design,
the framework to make sure the users' requests go to the process that holds the
corresponding virtual browser.
Second, we need to make useful features like application instance and
deployment configuration work in the new multi-process design.
For instance, application instance is a feature that allows multiple virtual browsers
to share objects, we need to make sure the virtual browsers of the same application 
instance are on the same process.
Third, as we break the functionalities to multiple processes,
some intra-process method calls need to be transformed to inter-process message
communication.
We do not want to write message passing code directly in our framework as it
will damage the code readability, and it is cumbersome to design message protocol
and write sending receiving code for every possible methods.

Chapter~\ref{ch:impl} and Chapter~\ref{ch:api} will discuss the implementation detail
of \cbtwo that deals with the first two challenges.
In chapter~\ref{ch:rmi}, 
we introduce a remote procedure call framework nodermi~\cite{nodermi} that we developed
to face the third challenge.
Although it is developed to support \cbtwo,
nodermi is a general purpose RPC framework that could be utilized by
any \nodejs project.
