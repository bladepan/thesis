\section{Secure Access to Framework Object}
\label{sec:api}

There are many use cases when an application needs to access framework's
internal objects. For administrator applications that monitor and manage the
system, nearly every feature requires access to the framework's internals. For
instance, in our administration dashboard one can view all the installed
applications and upload new applications. For general purpose applications,
some common tasks could only be implemented by the framework. For example, in
a chat room application, a user can terminate a chat room (i.e. application
instance) and close all its associated chat windows (i.e. virtual browser).

We designed an API layer such that the applications can only call the
framework methods via the API. We do not allow the applications call framework
code directly for the following reasons:

\begin{description}

\item[Security] \cb has a privilege system (discussed in
Section~\ref{sec:worker})  that manages the permissions of users. For example,
only the system administrator is allowed to shutdown all the  applications. We
want to enforce permission check so that users' actions  are limited by the
privilege system. Using the internal API directly, the application code could
easily allow any user to do almost anything. The only way to do it is
providing an intermediate level  that checks privilege violations between the
application code and the framework.

\item[Isolation] With direct access to internal objects, the application  code
could manipulate them in unexpected ways thus poses great threat to  the
integrity of the framework. Even the application is well implemented, the
coupling between application and framework internals makes the changes made to
the framework code could easily break the existing applications. Also with
direct access to framework objects, the application could prevent framework
objects from properly released. On the other direction, via method calls, the
framework could also hold references to the application objects, thus prevent
the application objects allocated inside a virtual browser from being
reclaimed after the virtual browser's destruction. 

\end{description}


\subsection{Overall Design}

The first objective is that the API should provides enough features to cover
all the scenarios where the applications need to access framework internals.
We designed the API alongside developing several example applications
including some administrator applications and some general multiple user
applications. In our experience, the current API covers the essential features
that are commonly needed. We concluded that the API should allow developers to
access applications, application instances and virtual browsers in the whole
system. Besides these internal objects, the API should also provide some
auxiliary services like sending emails. Below are the key classes we designed
for the API:

\begin{description}
\item[APICloudBrowser]
The entry point for the application.
For every virtual browser one APICloudBrowser object is created and injected as
a global variable in the application code namespace.

\item[APIApplication] Represents an application in the framework.
It contains methods to manipulate the associated application, such as modify the application's
description, change its owner, close the application, etc.

\item[APIAppInstance] Represents an application instance in the framework.
It has methods to manipulate the associated application instance.

\item[APIBrowser] Represents a virtual browser in the framework.
It has methods to manipulate the associated virtual browser.

\end{description}

\apiclassfig{}

Initially, the application code can get a reference to a
\emph{APICloudBrowser} object. As emphasized in
Figure~\ref{fig:apiclass}, via this object, the application code can get API
objects representing applications, application instances and virtual browsers.


\subsection{Implementation}

API objects themselves are just proxies of the internal objects they
represented so they need to keep reference to these internal objects. If we
referenced the internal objects as properties of the API objects, the
application code can get reference to internal objects via reading
properties  since there is no language support for private properties in \js.
Using hidden non-enumerable property is not safe either because the
application code can guess the property name.

We use closure visibility to implement a equivalence of private property as
shown in Listing~\ref{code:apiconstructor}. We store internal objects as local
variables in the API objects' constructors and define API methods inside the
constructors. Then in the API methods we can reference internal objects
directly because the API methods and the variables referencing to the internal
objects are in the same closure. The application code cannot get the
references to internal objects because they cannot be read as properties or be
revealed by reflection.


\begin{listing}[ht,width=\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
// constructor. virtualBrowser is the actual virtual browser object
function APICloudBrowser(virtualBrowser){
    // store the internal object as a local variable
    var virtualbrowser = virtualBrowser;
    // define API methods here
    this.close = function(){
        // check if the user has the privilege to close this virtual browser
        privilegeCheckingCode();
        // forward the operation to the internal object
        virtualbrowser.close();
    };
}
\end{minted}
\caption{Snippet of Class APIBrowser: the API Class for virtual browsers}
\label{code:apiconstructor}
\end{listing}


Because the application code can hold reference to internal objects indirectly
through API, it is possible that a virtual browser hogs large amount of memory
by keeping alive the internal objects that are no longer needed elsewhere in
the system.  For example, if a page lists all the virtual browsers in the
system, then it holds references to these virtual browsers indirectly. Then
the closed virtual browsers can not be reclaimed if such references exist.
To avoid this issue, the API objects only keep weak references to the internal
objects(See Figure~\ref{fig:apireference}). We use a \nodejs{} package node-
weak~\cite{nodeweak} to implement weak reference. Unlike ordinary references,
the objects referenced only by weak references are free to be garbage
collected. Using this method, the internal objects can be garbage collected
if they are no longer needed in the framework.


\apireferencefig{}


The framework can also obtain references to the application object.  Right now
these references are created by the event register methods provided by API for
the application to register event listeners to internal objects. For example,
the application can register a event listener to notify the current user when
someone shares an virtual browser to him. Because these listeners are
registered via API, the API layer remembers these listeners and unregister
them when the virtual browser's \code{close} method is called. In this way,
when a virtual browser is closed, the framework won't keep reference to the
objects it created.
