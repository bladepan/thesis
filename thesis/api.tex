\chapter{Application Programming Interface}
\label{ch:api}
\markright{Application Programming Interface}
Besides DOM API and built in types and methods,
we created a set of API for the developers to access server side resource.
We want programmers be able to manipulate server side objects like
applications, application instances and virtual browsers.
For example, in the administration dashboard(which is a \cb application),
we want to list all the applications and modify applications' descriptions.
For other applications, it is reasonable to give the programmer
the ability to control the server side objects to accomplish
tasks like closing a view(virtual browser) when it is no longer needed.
We design a separate API instead of letting developers directly use the internal
API of the framework because we want to enforce authentication check so that 
the user could only do what he has the right to do.
For example, we want ensure the current user could only close the virtual browser
he owns.

\section{Overall Design}
We have four classes in the API represents internal objects in the framework.
To avoid confusion, we add API prefix to these class names.

\begin{enumerate}
\item APICloudBrowser: An entry point API object, 
has a method to list all the applications. 
For every virtual browser one APICloudBrowser is created and injected as
a global variable in the browser's window.

\item APIApplication: Represents an application in the framework.
Contains a method to list the application's application instances.
Has methods to manipulate the application, such as modify the application's
description, change its owner, un-install the application, etc.

\item APIAppInstance: Represents an application instance in the framework.
Contains a method to list the application instance's virtual browsers.
Has methods to manipulate the application instance.

\item APIBrowser: Represents a virtual browser in the framework.
Has methods to manipulate the virtual browser.
\end{enumerate}
The internal objects are always wrapped in API objects before handed
to the application code.
For example, when the caller invokes \emph{list applications} method
of \emph{APICloudBrowser}, a list of \emph{APIApplication} objects 
are returned instead of actual application objects.
The reason we do not return the internal objects is obvious:
First, we want to protect the internal state of the framework from 
being tampered by application code.
Second, 
the application code could call methods of the internal objects directly
thus bypass the authentication check we put in the API methods.

API objects themselves are just proxies of the internal objects,
they need to keep reference to these internal objects.
We cannot store the internal objects as properties of the API objects,
because there is no language support for private properties in \js,
the application code could get reference to internal objects
via reading properties.
Using hidden non-enumerable property is not safe because the application
code could guess the property name.
We use closure visibility to implement a equivalence of private property as
shown in Listing~\ref{code:apiconstructor}.
We store internal objects as local variables in the API objects' constructors
and define API methods inside the constructors.
Then in the API methods we could reference internal objects directly 
because the API methods
and the variables reference to the internal objects are in the same closure.
The application code cannot get the references to internal objects because
they cannot be read as properties or be revealed by reflection.


\begin{listing}[ht,width=\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
// constructor. virtualBrowser is the actual virtual browser object
function APICloudBrowser(virtualBrowser){
    // store the internal object as a local variable
    var virtualbrowser = virtualBrowser;
    // define API methods here
    this.close = function(){
        // check if the user has the privilege to close this virtual browser
        privilegeCheckingCode();
        // forward the operation to the internal object
        virtualbrowser.close();
    };
}
\end{minted}
\caption{Snippet of Class APIBrowser: the API Class for virtual browsers}
\label{code:apiconstructor}
\end{listing}


As the application code could hold reference to internal objects indirectly
through API,
it is possible that a virtual browser hogs large amount of memory
because it keeps alive internal objects that are no longer needed in
the framework.
To avoid this issue, the API objects only keep weak references to the
internal objects(See Figure~\ref{fig:apireference}).
We use a \nodejs{} package node-weak~\cite{nodeweak} to implement weak reference.
Unlike ordinary references, the objects referenced only by weak references are
free to be garbage collected.
Using this method, 
the internal objects could be garbage collected if they are no longer needed in
the framework.


\apireferencefig{}
