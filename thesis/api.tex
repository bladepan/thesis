\section{Secure Access to Framework Object}
\label{sec:api}

There are many use cases when an application needs to access framework's
internal objects. For administrator applications that monitor and manage the
system, nearly every feature requires access to the framework's internals. For
instance, in our administration dashboard one can view all the installed
applications and upload new applications. For general purpose applications,
some common tasks could only be implemented by the framework. For example, in
a chat room application, a user can terminate a chat room (i.e. application
instance) and close all its associated chat windows (i.e. virtual browser).

We designed an API layer such that the applications can only call the
framework methods via the API. We do not allow the applications call framework
code directly for the following reasons:

\begin{description}

\item[Security]  We want to enforce permission check for users' actions so that
they do not violate the permission settings (discussed in
Section~\ref{sec:worker}). For example, only the system administrator is
allowed to shutdown all the  applications. 
If we allow the application use the internal API directly,
the application can allow any user do anything.


\item[Isolation]  First, we want to prevent the application code from
manipulating the internal objects in unexpected ways. Second, we want to
decouple the application code and the framework code so  that changes made to
the framework code do not break the applications.   Third,   we want the
framework objects to be available for garbage collection after they are no
longer needed by the framework,  and the objects created by application code
to be available for garbage collection after their associated virtual browsers
and \appins{}s are closed.  If the applications are allowed to access the
framework objects directly,   it is impossible to fulfill these requirements
since the objects created by application code and framework objects can create
references to each other.

\end{description}


\subsection{Overall Design}

The \cb API has four major classes covering essential features applications
need to access framework objects.

\begin{description}

\item[APIBrowser] Represents a virtual browser.
It has methods to manipulate the associated virtual browser, such as
set the browser's permissions, close the browser, etc.

\item[APIAppInstance] Represents an \appins{}. It has methods to manipulate
the associated \appins{} and list the \appins{}'s virtual browsers as 
\emph{APIBrowser} objects.


\item[APIApplication] Represents an application object.
It has methods to manipulate the associated application
and list the application's \appins{}s as \emph{APIAppInstance} objects.


\item[APICloudBrowser]
It has methods to manage applications and list applications as \emph{APIApplication} objects.
For every virtual browser one single APICloudBrowser object is created and injected as
a global variable in the application code namespace.

\end{description}

\apiclassfig{}


Initially, the application code can get a reference to a
\emph{APICloudBrowser} object. As shown in Figure~\ref{fig:apiclass}, from
this object, the application code can get API objects representing
applications, application instances and virtual browsers. 
For most cases, the
current application object, the current \appins{} and the current virtual browser are
the most frequently visited framework objects for the application code, thus
the \emph{APICloudBrowser} object also contains API object properties
represent these objects so that  the application code can get reference to
these API objects without calling a chain of methods. Besides framework
objects, the \emph{APICloudBrowser} object also contains properties that
provide auxiliary services such as sending emails.


\subsection{Implementation}

API objects are implemented in proxy design pattern :  when their methods are
called, they will first perform permission checking if necessary and then call
the corresponding methods of the framework objects they represent. Proxy
design pattern requires the proxy objects keep references to the objects they
represent. Typically these references are implemented by private properties so
that  the caller of the proxy objects cannot get reference to the the objects
being represented. Since there there is no language support for private
properties in \js, we cannot  store the internal objects as properties of the
API objects because the  application code can get reference to internal
objects via reading properties. Even we use  hidden non-enumerable property
the application code can still guess the property name.

We use closure visibility to implement an equivalence of private property as
shown in Listing~\ref{code:apiconstructor}. We store internal objects as local
variables in the API objects' constructors and define API methods inside the
constructors. Then in the API methods we can reference internal objects
directly because the API methods and the variables referencing the internal
objects are in the same closure. The application code cannot get the
references to internal objects because they cannot be read as properties and they
cannot be revealed by reflection.


\begin{listing}[ht,width=\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
// constructor. virtualBrowser is the actual virtual browser object
function APICloudBrowser(virtualBrowser){
    // store the internal object as a local variable
    var virtualbrowser = virtualBrowser;
    // define API methods here
    this.close = function(){
        // check if the user has the privilege to close this virtual browser
        privilegeCheckingCode();
        // forward the operation to the internal object
        virtualbrowser.close();
    };
}
\end{minted}
\caption{Snippet of Class APIBrowser: the API Class for virtual browsers}
\label{code:apiconstructor}
\end{listing}

To avoid holding references to the internal objects that are no longer needed
by the framework, the API objects only keep weak references to the internal
objects(See Figure~\ref{fig:apireference}). We use a \nodejs{} package node-
weak~\cite{nodeweak} to implement weak reference. Unlike ordinary references,
the objects referenced only by weak references are free to be garbage
collected.
In this way, when an internal object is no longer referenced
inside the framework, it is available for garbage collector even it is still
referenced by API.


\apireferencefig{}


The framework can also obtain references to the objects created by application
code.  Right now these references are created by the event register methods
provided by API for the application to register event listeners to internal
objects. For example, the application can register a event listener to notify
the current user when someone shares an virtual browser to him.  Because these
listeners are registered via API, the API layer is able to remember these
listeners. When a virtual browser's \code{close} method is called, the API
unregisters the event listeners created by the virtual browser. In this
way, when a virtual browser is closed, the framework won't keep reference to
the objects it created.
