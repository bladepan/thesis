\chapter{Background}
\markright{Background}

This chapter gives background information to understand the concept of \cbtwo.
We assume the reader has the basic knowledge of web development.
The reader should understand the meaning of HTTP~\cite{rfc7231}, HTML~\cite{hickson2012html}, 
DOM~\cite{2000Document}, \js~\cite{ecmascript2011ecmascript} and CSS~\cite{css21}.

\webscaleoutfig{}

\section{Scalable Web Server Architectures}
\label{sec:websys}

Web systems are system platforms that host web applications.
For example, a web system could be a machine running a web
server software serving static contents.

Scalability is an important issue for web systems.
Even in the early 90s, the first web system experienced a load rose by a factor
of 10 every year~\cite{berners1998world}.
Even without the increasing user access,
web applications could demand more resource as they become more sophisticated.
Figure~\ref{fig:webscaleout} is a diagram of scalable web systems.
In a scalable web system, web applications are able to efficiently 
harness resource from a cluster of servers.
We divide the servers in such web systems into two layers.
The web layer processes the HTTP requests from users
and generate HTTP response which will be rendered in users' browser.
The web layer offload storage and computation tasks to a storage layer
consists of database servers and other types of servers.
The benefit of layered design is manifold:
it makes the web servers light weight so they could handle more concurrent 
connections;
the whole system becomes modular,
the system owner could upgrade parts of the system without interfering
other parts.
Besides the web layer and the storage layer,
the load balancer is another important part of a web system.
The load balancer sits between the clients and the web layer,
it  distributes user's requests web servers
and return the response from the web servers to users.
From the user's point of view, 
he only needs one identifier to
access the web system, that could be a DNS~\cite{rfc1034} name or an IP address.
It is the load balancer's job to hide 
the distributed architecture
 from the user.
There are many ways to implement load balancer~\cite{cardellini2002state}.
For instance, 
we could
deploy reverse proxy software (like nginx~\cite{nginx})
on a group of servers
and configure the system's DNS name pointing to those servers,
then all the client traffic will be directed to reverse proxy servers
and reverse proxy will distribute the traffic to the web layer.
It is also possible that the load balancer layer is implemented purely in logic 
with no dedicated servers.
One way to do it is
 registering all the web servers' public IP addresses to the DNS server
and rely on the DNS server return these IP addresses to clients in a round-robin
fashion.
From now on, we will only discuss the distribution algorithm without meddling too much
in the implementation details of the load balancer layer.

% \subsection{Application State Management}% maybe too big a title for a short review...

% We use application state to describe 
% the data web applications need to 
% process user requests and render user interface.
% Based on the design of the web application,
% the application state could comprise data fetched from some permanent
% storage or 
% generated during the execution of the application.
% On the other direction,
% the data in application state could be written back to permanent
% storage or just be kept transiently.
% The application state data that stored permanently could
% endure server restart and be referenced in the future,
% it usually contains data that is costly or impossible to 
% recreate, like user profile, shopping transactions, etc.
% The application state data that is transient 
% usually represents state that is acceptable to be lost
% during server restart or client crash.


% To distinguish individual users, the web application assigns 
% a unique session identifier for each user.
% The session identifier is then attached to every HTTP requests.


\subsection{Session State Management}

We use session state to describe the application context
web applications need to maintain for each user.
It is generally acceptable to lose session state
when server restarts,
because session state could be recreated from scratch.
Session state is partitioned on client side and server side.
Usually the web application would assign a unique 
session id for each user and uses
the session id to associate the client side session state
with server side.
Most web frameworks provides two modes
to manages session state~\cite{j2eedoc}~\cite{phpdoc}:
a local mode where server side session data is stored
in memory or in file system,
a distributed mode where server side session data
is stored in a centralized storage system usually a
relational database.
It is easy to see that the local mode has better performance
than the distributed mode.


\subsection{Load Balance}

In this section we discuss the design choices of load balancer in a web system
and how the implementation of load balancer impacts the application development.

We use the taxonomy from the survey of Cardellini et al.~\cite{cardellini2002state}
to categorize the load balancer into client-blind or client-aware based on if
the load balancer uses any information from client request to perform the dispatch.

A client-blind load balancer does not use information from client.
For example, it could randomly select a web server from the web layer for each request,
or use a round robin algorithm to pick web server one by one.
In this case, the requests from the same client could be relayed to any web server.
The developer cannot naively use a local mode session implementation
, because as the requests from a user hit multiple servers,
multiple copies of session state would be created on these servers,
the discrepancy in these copies could cause application bugs not to mention
it is a waste of space to store multiple copies.
The application has to move session state to a centralized
storage system and fetch the session state for every request.
One solution would be move as much session state to the client side as possible,
then the client would attach its part of session state
with the requests to reduce the cost on the server side.
However, the server side still needs to keep part of the session state
because it is risky to store all session state on
the client side.
For example,
the server might need the client's user profile to check if the client has
the privilege to do a certain task.
It is obvious that server should not trust the user profile passed by the client
as a misbehaved client could forge a user profile in its requests.
Another solution would be synchronizing local mode session data among web servers
as implemented in Tomcat's session replication mode~\cite{tomcatcluster}. % and JBOSS
This solution is expansive because it needs to broadcast
changed session data to all web servers.

A client-aware load balancer dispatches the request from the same
client to the same web server.
In this model, the web server could use the local mode session implementation.
The downside is the load balancer needs to discriminate each client
to make the correct routing decision.
One way to do it is parsing the HTTP request header to get
the session identifier,
then the load balancer computes a hash value of
the session identifier and map the hash value to a web server.

% Another aspect that needs to be consider to design a scalable web system
% is the servers' load.
% The servers' load could be drastically uneven if the load balancer
% does not take the servers' state into the distribution process.

% Current web frameworks usually only deals with the Client Layer and the Web Layer,
% the web application developer should take the distribution policy of the load balancer
% into consideration when designing web applications,
% and they would need to configure or implement the load balancer to support
% the needs of the application.


% Current web frameworks do not have clear construct to define application state.
% One option for the developer is to rely on session objects provided by frameworks.
% The application developer needs to configure the persistence  of session objects
% and make sure the configuration works with the load distribution scheme.
% For example, in J2EE the session objects could be configured to be managed in memory or
% high available database~\cite{j2eedoc};
% in PHP developers could specify a session save handler to store session objects
% in database~\cite{phpdoc}.
% By default, these frameworks store session objects in memory or in local file system.
% If the developer adopts a client-blind load balancer,
% he needs to configure the session objects to use database or other
% synchronization mechanism to make sure the application state could be fetched on every server.
% Another option is to implement his own way of handling application state.
% Regardless of the choices of managing application state,
% the developer needs take the distribution policy of the load balancer
% into consideration when designing web applications,
% and in the other direction,
% the developer needs to find the right load balancer to support his application.






\section{\nodejs}

\cb is written in \nodejs.
\nodejs~\cite{tilkov2010node} is a platform that built on Google Chrome's V8~\cite{v8} \js engine.
Simply put, \nodejs is a standalone \js runtime that allows \js code to be
executed without a web browser.
It is also regarded as server side \js in contrast to typical \js code that executed in
client side web browsers.
\nodejs comes with a standard library that provides API
such as file system access, network IO, binary data manipulation, etc.
that makes it possible to write server side network applications using \js.
\nodejs is appealing for building high performance scalable web applications
because it adopts a non-blocking event driven IO model which makes it capable 
to handle a large number of concurrent connections.
\nodejs is widely adopted in the web development community,
a lot of third party packages are developed.
Another bonus for using \nodejs is that the \cb framework code and application code
are in the same language, there is language crossing cost.
In this section we will discuss the \nodejs's non-blocking IO model and some important
third party packages we used.

\subsection{Non-blocking IO}

\begin{listing}[ht,width=\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
var fs = require('fs');
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
console.log("Reading file");
\end{minted}
\caption{Reading file and printing the content on console using \nodejs.}
\label{code:nodefile}
\end{listing}

Listing~\ref{code:nodefile} shows the non-block IO concept in \nodejs.
Because the IO API such as \emph{readFile} does not
block, line 6 will be executed before line 3.
To execute code after the IO operation completes,
the developer needs to register a callback function to be fired asynchronously.
In this example, after the file's content is read the callback function is placed on the
event loop,
then the runtime would dequeue this callback sometime in the future and execute it.
Like in a web browser, \nodejs execute \js code in a single thread,
and the runtime will not halt the current execution in the middle to execute something in
the event loop, so it is easy to write concurrent safe programs.
The event based non-blocking IO and simple execution semantics
is key to the performance of \nodejs,
the downside is that any operation that waits for IO must be implemented as a callback.

\subsection{Node-http-proxy}

Node-http-proxy~\cite{nodeproxy} is a \nodejs package for developing HTTP proxies.
It provides programming interface to relay a HTTP request to another server and
automatically copy the response from that server to the original requester.
It also supports WebSocket~\cite{rfc6455} protocol.
WebSocket is a TCP-based protocol which provides bidirectional full-duplex communication
mechanism for web browsers.
Using WebSocket, the server could send content to the client without requested
by the client.
Because WebSocket sends messages while keep the connection open,
it is cost efficient comparing to using HTTP requests.
We use WebSocket to implement DOM synchronization between client and server so
the server could push DOM changes to clients.
In node-http-proxy,
the programmer needs only to provide the destination server on the hand shake
request and all the subsequent WebSocket messages will
be transparently proxyed to the destination server.

\subsection{Jsdom}

Jsdom~\cite{JSDOM} is a \nodejs package which provides a \js implementation of 
DOM API. We use jsdom to implement server side DOM tree.
Jsdom works like a web browser except it does not render the DOM tree:
it reads HTML documents to build the initial DOM tree,
it also executes \js files specified in script tags.
It is possible to create multiple jsdom instances in a same process,
each of these jsdom instance will have its own DOM tree and
script execution environment,
the scripts in each jsdom instance will have its own isolated view of global variables.
In our model, each virtual browser has one jsdom instance and
forwards client events to the jsdom DOM tree.
We also patched jsdom to get notifications for DOM updates.


\section{\cb}

\architectureoverview{}

In this section we sketch the implementation of
the original single process version \cb{}~\cite{mcdaniel2012cloudbrowser}.
Figure \ref{fig:cb1arch} shows the relationship
between the client engine running in the user's browser and the virtual browser
running server side.  When the user visits the application, the client engine
code is downloaded and restores the current view of the application by
copying the current state of the server document.  Subsequently, user input
is captured, forwarded to the server engine inside the virtual browser,
which then dispatches events to the document.  All application logic runs
in the global scope associated with the virtual browser's window object.
Since the server environment faithfully mimics a real browser, libraries
such as AngularJS~\cite{hevery2009angular} can be used unchanged to implement the user interface.
Client and server communicate through a lightweight RPC protocol that is
layered on top of a bidirectional WebSocket communication.
Stylesheets, images, etc. are provided to the client through a resource
proxy.

\subsection{Deployment Model}
\label{sec:deploymodel}
\appbundlefig{}
As shown in Figure~\ref{fig:appbundle}, 
a \cb application bundle is a directory
contains descriptor files, an entry point HTML file,
\js files and resources files like CSS files, images, etc.
The descriptor files specify the application's name, owner, mount point, and
other application's configuration.
Mount point is the URL path to the application, for example,
if a \cb is deployed at \url{example.com} and an application's mount point is
\emph{chat}, the user could access the application at \url{http://example.com/chat}.
The \js files include libraries like AngularJS or JQuery
, the application code and an optional application instance(explained 
in Section~\ref{sec:appins}) definition.
Like in regular browser, the entry point HTML should have script tags
specifying the \js files the developer wants to be executed in virtual browsers.

The developer could put the application bundle in \cb's application 
directory or upload the bundle using \cb's administrator application.
Multiple applications could be deployed simultaneously.

\apphierarchyfig{}

As emphasized in Figure~\ref{fig:appidhierarchy},
an application could create multiple application instances,
each application instance could create multiple virtual browsers,
a virtual browser could be simultaneously accessed by multiple clients.
% For example, in our chat room example application, multiple clients
% can join one chat room and each client get his own view of the
% chat room.
% In our model, the chat room concept is represented by application instance,
% the user's view of chat rooms are represented by virtual browsers.
% When a user request the chat room application's URL,
% he is redirected to a page that lists all the chat rooms(in essential application instances) 
% he joined.
% From there, the user could manage his application instances.
% He could create a new application instance(chat room) and share the application
% instance's URL to let others join in.
% When a user joined a chat room,
% a virtual browser is created for him so he could interact with the application.
% A virtual browser could also be accessed by multiple clients,
% the DOM updates from the virtual browser will be broadcast to all connecting
% clients to provide a co-browsing experience.



\subsection{Application Instance}
\label{sec:appins}
\appinstancefig{}


Application instance allows multiple virtual browsers to share data structure.
As in Figure~\ref{fig:appinstance} shows, 
every virtual browser is created inside an application instance
and virtual browsers inside an application instance share application instance object.
The application instance itself
consists metadata about the application instance object
 such as ownership and access permissions.
The application instance object is defined
the application instance definition file 
in the application bundle (see Figure~\ref{fig:appbundle}).
When a virtual browser is created in the application instance,
the application instance object is injected into that virtual browser
and the application code could reference it directly.

\chatappfig{}

As an example, consider a scenario for a Chat application developed using AngularJS,
depicted in Figure~\ref{fig:chatapp}.
A system administrator of a \cb deployment would install the application, which give users the
ability to create application instances. To start a chat site, a user would create
an application instance and share its URL with chat participants.  As the participants join
the chat site, a virtual browser is created on demand for each participant, which is connected
to the application instance (the users can bookmark their virtual browser's URL to later return.)
The shared application instance data in such an application
consist of the chatroom(s), users and their associated messages.  The advantage of this design
is that AngularJS's dirty-checking mechanism will reflect updates to the shared instance data
in each virtual browsers' document automatically, thus ensuring that new message are broadcast
to each.



\subsection{Application Instantiation Strategy}
\label{sec:appinstantiation}

The application instantiation strategy specifies
how the application instance and virtual browsers are instantiated.

Application programmers can create CloudBrowser applications in the same way in which
they create the client-side portion of a client-centric application, using low or high level
JavaScript libraries such as jQuery~\cite{jquery} or AngularJS.  
A descriptor in the application's manifest describes 
their application's instantiation strategy.
The supported strategies include

\begin{description}

\item[singleAppInstance] The application supports only one instance and single virtual browser.
    All connected clients will share a single server-side document in this singleton - this can be
    used for applications that display data, such as a weather application. These applications will not
    typically react to user input and users do not need to be authenticated.

\item[singleUserInstance]  This application requires authentication to establish a
    user identity, which we provide through a local database as well as through external OpenID
    authentication.   In this mode, users may not create more than one virtual browser per
    application instance.  When a user accesses the application instance's URL, they will either
    be forwarded to their virtual browser or a virtual browser will be instantiated for them.

\item[multiInstance]
    Allows users to have multiple, separate virtual browsers connected to an application
    instance. For instance, a user may have to be in two separate chatrooms offered by one chat site.
    In those cases, the user has the largest flexibility, but will need to manage whether
    to join an existing virtual browser or create a new one when they visit the application instance
    - similar to the choice a user may have when deciding whether to navigate to a new site in
    an existing browser tab or open a new one.

\end{description}

Except for multiInstance applications, the existence of virtual browsers is not exposed to
end users that merely join existing application instances.


% The hierarchy that results from applications, application instances, and virtual browsers is
% depicted in Figure~\ref{fig:appidhierarchy}.  This figure shows the general case in which an
% application might allow multiple instances, and in which each user can create multiple virtual
% browsers.


