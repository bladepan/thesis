\chapter{Background}
\markright{Background}

This chapter provides background information to understand the concepts
underlying the design of \cbtwo. We assume the reader has basic knowledge of
web-related protocols and languages, including HTTP~\cite{rfc7231},
HTML~\cite{hickson2012html},  DOM~\cite{2000Document},
\js~\cite{ecmascript2011ecmascript} and CSS~\cite{css21}.

\webscaleoutfig{}

\section{Scalable Web Server Architectures}
\label{sec:websys}

\cbtwo aims to provide a scalable platform for web applications.
In this section we introduce some typical methods to design
scalable architectures for web applications.

Web servers provide the infrastructure on which web applications 
are hosted.
Scalability is an important issue for web servers as the number of users
visiting a site can grow significantly~\cite{berners1998world}.
Even without the increase in users,
web applications demand more resources as they become more sophisticated.

Figure~\ref{fig:webscaleout} is a diagram of a typical scalable web server
architecture, which is able to harness resources from a cluster of servers. We
divide the servers in such web systems into two layers. The web layer
processes HTTP requests from users and generates HTTP responses which will be
rendered in the user's browser. The web layer offloads storage and
computational tasks to a storage layer that consists of database servers or
other types of storage servers. The benefit of such layered design is twofold:
it makes the web servers lightweight so they are able to handle more
concurrent  connections; the whole system becomes modular, so that the system
operator can upgrade parts of the system without interfering with other parts.

To balance requests evenly across the web servers, a load balancer component
sits between the clients and the web layer, which dispatches user requests to
web servers and returns the responses from the web servers to users. The use
of a load balancer allows users to access the web server using a single URL
because it hides the distributed architecture from the user. There are many
ways to implement load balancing~\cite{cardellini2002state}. We can use round-
robin DNS~\cite{} to distribute the load to multiple addresses. First, we need
to register a list of IP addresses to the DNS server. The DNS server orders
the registered addresses in round-robin fashion
 and return the ordered
addresses for every DNS query from the user.  The user will use the first
address in the returned list to issue requests. Considering the effect of DNS
caching, some users will send requests to the first address in the registered
list, some users will send requests to the second address in the list, and so
forth. We can expose  all web servers directly to the clients  by registering
all web servers' public IP addresses using round-robin DNS. In this way,
clients directly issue requests to the web servers. However, this solution is
not flexible about adding or removing web servers. To overcome limitations of
DNS based load balancing, people often add a layer of reverse proxies \footnote{A
reverse proxy (such as nginx~\cite{nginx})  forwards user requests to one or
multiple web servers and copies responses from the web servers back to the
users} between the clients and the web servers. We can register the IP
addresses of the reverse proxies to the DNS server. The user requests are
first distributed among the reverse proxies, then  the reverse proxies
distribute user requests across web servers.

From now on, we will only discuss the distribution algorithm without meddling too much
in the implementation details of the load balancer layer.
%
%  REVISE TO HERE
%

% \subsection{Application State Management}% maybe too big a title for a short review...

% We use application state to describe 
% the data web applications need to 
% process user requests and render user interface.
% Based on the design of the web application,
% the application state could comprise data fetched from some permanent
% storage or 
% generated during the execution of the application.
% On the other direction,
% the data in application state could be written back to permanent
% storage or just be kept transiently.
% The application state data that stored permanently could
% endure server restart and be referenced in the future,
% it usually contains data that is costly or impossible to 
% recreate, like user profile, shopping transactions, etc.
% The application state data that is transient 
% usually represents state that is acceptable to be lost
% during server restart or client crash.


% To distinguish individual users, the web application assigns 
% a unique session identifier for each user.
% The session identifier is then attached to every HTTP requests.


\subsection{Session State Management}

The web applications use session state to remember user-related information across HTTP requests
so they can provide user specific service using stateless HTTP protocol.
The session state is store on the server side indexed by session ids.
The web applications assign a unique session id for each user and 
use this session id to retrieve the user's session state for each request.
For the first request, the sever automatically creates a session state for the user.
The applications could store various information in a user's session state
such as user profile, a shopping cart, etc.

Most web frameworks provides two modes to manages session
state~\cite{j2eedoc}~\cite{phpdoc}: a local mode where server side session
data is stored in memory or in file system, a distributed mode where server
side session data is stored in a storage system usually a relational database.

If session state is stored locally, it can be accessed faster, but it is not
accessible from other web server instances.  To overcome this limitation, some
web servers like Tomcat support a session replication
mode~\cite{tomcatcluster} that  synchronizes locally stored session state
across the whole cluster of web servers . Since a web server needs to
broadcast session state changes to all other web servers,  this mode is
expensive when there are many web servers.

Large scale web applications usually adopt distributed mode session.
Besides traditional rational database,
the backend session storage could be implemented by high performance key value
store such as redis or distributed data stores such as memcached, Cassandra, etc.


\subsection{Load Balancing}

In this section we discuss the design choices regarding load balancing and how
its implementation impacts application development.

We use the taxonomy from the survey of Cardellini et
al.~\cite{cardellini2002state} to categorize the load balancer into client-
blind or client-aware based on if the load balancer uses any information from
the client request to perform the dispatch.

A client-blind load balancer does not use information from client when
deciding how to dispatch a request. For example, it could randomly select a
web server from the web layer for each request, or use a round robin
algorithm. In this case, multiple requests from one client could be relayed to
different web servers. In this design, session state cannot be stored locally,
rather it must be accessible  from any server handling the client's request.
For every request, the web server needs to fetch the session state from
session storage and pushes the changes back to session storage if session
state is modified.


A client-aware load balancer dispatches every request from a given client to
the same web server. In this model, the web server can use the local mode
session implementation, which is faster. The web server can also use the
distributed mode to store session data so that the session data could endure
web server restart. Since a given client's requests are dispatched to the same
server, the web server can cache session data to get a better performance.  In
this way,   The web server retrieves session state once for every user and
only communicate with the storage system when session data changes. The
downside for the client-aware load balancer  is that the load balancer needs
to identify each client's assigned server to make the correct routing
decision. For instance, the load balancer needs to examine the HTTP request
header to extract the session identifier and assign web servers based on a
hash of this identifier.

Because different request can impose different load on a web server, the
simple implementations mentioned above can cause uneven load distribution
among web servers. Especially for modern web applications with long
connections, the time a connection keeps open can vary from milliseconds to
hours. A naive load balancer can keep distributing requests to an already busy
server when there are servers idle in the cluster. The load balancer can also
be server-aware such that  it  takes servers' load information into
consideration when making dispatching decisions. Because client-aware load
balancing has the restriction of keeping requests from a given user to the
same server, server-aware client-aware load balancing is more complex than
server-aware client-blindness load balancing.
 
% Another aspect that needs to be consider to design a scalable web system
% is the servers' load.
% The servers' load could be drastically uneven if the load balancer
% does not take the servers' state into the distribution process.

% Current web frameworks usually only deals with the Client Layer and the Web Layer,
% the web application developer should take the distribution policy of the load balancer
% into consideration when designing web applications,
% and they would need to configure or implement the load balancer to support
% the needs of the application.


% Current web frameworks do not have clear construct to define application state.
% One option for the developer is to rely on session objects provided by frameworks.
% The application developer needs to configure the persistence  of session objects
% and make sure the configuration works with the load distribution scheme.
% For example, in J2EE the session objects could be configured to be managed in memory or
% high available database~\cite{j2eedoc};
% in PHP developers could specify a session save handler to store session objects
% in database~\cite{phpdoc}.
% By default, these frameworks store session objects in memory or in local file system.
% If the developer adopts a client-blind load balancer,
% he needs to configure the session objects to use database or other
% synchronization mechanism to make sure the application state could be fetched on every server.
% Another option is to implement his own way of handling application state.
% Regardless of the choices of managing application state,
% the developer needs take the distribution policy of the load balancer
% into consideration when designing web applications,
% and in the other direction,
% the developer needs to find the right load balancer to support his application.






\section{\nodejs}

\cb is written in \nodejs. \nodejs~\cite{tilkov2010node} is a standalone \js
runtime built on Google Chrome's V8~\cite{v8} \js engine that allows \js code
to be executed without a web browser.  \nodejs comes with a standard library
that provides API for file system access, network IO, binary data
manipulation, etc. It enables developers write server side network
applications using \js.  \nodejs is appealing for building high performance
scalable web applications because it adopts a non-blocking event driven IO
model which is capable  to handle a large number of concurrent connections
using a single thread.

\nodejs has a thriving community with a variety of third party packages.
We have relied on a lot of packages in \cb to implement complex tasks like
server side DOM or provide small useful functions like formating a date object.

Another reason we chose \nodejs is that we can write  \cb and the applications
using the same language, there is no language crossing cost.

In this section we will discuss the \nodejs's non-blocking IO model and some
important third party packages we used.

 % it is not parallel with the next section
\subsection{Non-blocking IO}

\begin{listing}[ht,width=\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
var fs = require('fs');
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
console.log("Reading file");
\end{minted}
\caption{Reading file and printing the content on console using \nodejs.}
\label{code:nodefile}
\end{listing}

Listing~\ref{code:nodefile} shows the non-block IO concept in \nodejs. Because
the IO API such as \code{readFile} does not block, line 6 will be executed
before line 3. To wait for the IO operation completes, the developer needs to
register a callback function in the IO method  to be fired asynchronously. In
this example, the callback function is placed on the event loop after the
file's content is read, then the runtime will dequeue this callback sometime
in the future and execute it. Unlike languages that support multiple threads
where code can be executed concurrently, \js runtime has only one execution
thread and it does not block. In this way,   thus the programmers do not need
to use mutual exclusion mechanisms like Locks. The drawbacks of this model is
that the programmers need to manually maintain the application context in the
callbacks  and  it is hard to reasoning the execution order of the code.
Listing~\ref{code:nodefile2} shows the necessity for programmers maintain the
application context in callback. Without keeping the current \code{fileName}
in closure using \code{createReadFileCallback}, line 18 will always print the
last \code{fileName} while line 6 will print the correct \code{fileName}.
There is also no guarantee that the callbacks will be called in the same order
they are registered because the events for these callbacks can happen in any
order. For instance, in Listing~\ref{code:nodefile2} line 6 the files can be
print in any order although their callbacks are registered in a fixed order.
It is also possible that a function that accepts a callback function executes
the  callback synchronously,  thus making the reasoning of the execution order
more difficult.


\begin{listing}[htb,width=0.8\columnwidth]
\begin{minted}[
frame=lines,
fontsize=\scriptsize,
linenos
]
{javascript}
var fs = require('fs');
var files = ['/etc/passwd', '/etc/hosts'];
var createReadFileCallback = function(fileName){
    return function(err, data){
        if (err) throw err;
        console.log("content of " + fileName + " is "+ data);          
    }
};
for (var i = 0; i < files.length; i++) {
    var fileName = files[i];
    fs.readFile(fileName, createReadFileCallback(fileName));
};
for (var i = 0; i < files.length; i++) {
    var fileName = files[i];
    fs.readFile(fileName, function(err, data){
        if (err) throw err;
        // this will always print "read /etc/hosts"
        console.log("read " + fileName);          
    });
}
\end{minted}
\caption{Reading 2 files in a loop using \nodejs.}
\label{code:nodefile2}
\end{listing}



\subsection{Important \nodejs Packages}

\subsubsection{Node-http-proxy}

Node-http-proxy~\cite{nodeproxy} is a \nodejs package for developing HTTP proxies.
It provides programming interface to relay a HTTP request to another server and
automatically copy the response from that server to the original requester.
It also supports WebSocket~\cite{rfc6455} protocol.
WebSocket is a TCP-based protocol which provides bidirectional full-duplex communication
mechanism for web browsers.
Using WebSocket, the server could send content to the client without requested
by the client.
Because WebSocket sends messages while keep the connection open,
it is cost efficient comparing to using HTTP requests.
We use WebSocket to implement DOM synchronization between client and server so
the server could push DOM changes to clients.
In node-http-proxy,
the programmer needs only to provide the destination server on the hand shake
request and all the subsequent WebSocket messages will
be transparently proxyed to the destination server.

\subsubsection{Jsdom}

Jsdom~\cite{JSDOM} is a \nodejs package which provides a \js implementation of 
DOM API. We use jsdom to implement server side DOM tree.
Jsdom works like a web browser except it does not render the DOM tree:
it reads HTML documents to build the initial DOM tree,
it also executes \js files specified in script tags.
It is possible to create multiple jsdom instances in a same process,
each of these jsdom instance will have its own DOM tree and
script execution environment,
the scripts in each jsdom instance will have its own isolated view of global variables.
In our model, each virtual browser has one jsdom instance and
forwards client events to the jsdom DOM tree.
We also patched jsdom to get notifications for DOM updates.


\section{\cb}

\architectureoverview{}

In this section we sketch the implementation of
the original single process version \cb{}~\cite{mcdaniel2012cloudbrowser}.
Figure \ref{fig:cb1arch} shows the relationship
between the client engine running in the user's browser and the virtual browser
running server side.  When the user visits the application, the client engine
code is downloaded and restores the current view of the application by
copying the current state of the server document.  Subsequently, user input
is captured, forwarded to the server engine inside the virtual browser,
which then dispatches events to the document.  All application logic runs
in the global scope associated with the virtual browser's window object.
Since the server environment faithfully mimics a real browser, libraries
such as AngularJS~\cite{hevery2009angular} can be used unchanged to implement the user interface.
Client and server communicate through a lightweight RPC protocol that is
layered on top of a bidirectional WebSocket communication.
Stylesheets, images, etc. are provided to the client through a resource
proxy.

\subsection{Deployment Model}
\label{sec:deploymodel}
\appbundlefig{}
As shown in Figure~\ref{fig:appbundle}, 
a \cb application bundle is a directory
contains descriptor files, an entry point HTML file,
\js files and resources files like CSS files, images, etc.
The descriptor files specify the application's name, owner, mount point, and
other application's configuration.
Mount point is the URL path to the application, for example,
if a \cb is deployed at \url{example.com} and an application's mount point is
\emph{chat}, the user could access the application at \url{http://example.com/chat}.
The \js files include libraries like AngularJS or JQuery
, the application code and an optional application instance(explained 
in Section~\ref{sec:appins}) definition.
Like in regular browser, the entry point HTML should have script tags
specifying the \js files the developer wants to be executed in virtual browsers.

The developer could put the application bundle in \cb's application 
directory or upload the bundle using \cb's administrator application.
Multiple applications could be deployed simultaneously.

\apphierarchyfig{}

As emphasized in Figure~\ref{fig:appidhierarchy},
an application could create multiple application instances,
each application instance could create multiple virtual browsers,
a virtual browser could be simultaneously accessed by multiple clients.
% For example, in our chat room example application, multiple clients
% can join one chat room and each client get his own view of the
% chat room.
% In our model, the chat room concept is represented by application instance,
% the user's view of chat rooms are represented by virtual browsers.
% When a user request the chat room application's URL,
% he is redirected to a page that lists all the chat rooms(in essential application instances) 
% he joined.
% From there, the user could manage his application instances.
% He could create a new application instance(chat room) and share the application
% instance's URL to let others join in.
% When a user joined a chat room,
% a virtual browser is created for him so he could interact with the application.
% A virtual browser could also be accessed by multiple clients,
% the DOM updates from the virtual browser will be broadcast to all connecting
% clients to provide a co-browsing experience.



\subsection{Application Instance}
\label{sec:appins}
\appinstancefig{}


Application instance allows multiple virtual browsers to share data structure.
As in Figure~\ref{fig:appinstance} shows, 
every virtual browser is created inside an application instance
and virtual browsers inside an application instance share application instance object.
The application instance itself
consists metadata about the application instance object
 such as ownership and access permissions.
The application instance object is defined
the application instance definition file 
in the application bundle (see Figure~\ref{fig:appbundle}).
When a virtual browser is created in the application instance,
the application instance object is injected into that virtual browser
and the application code could reference it directly.

\chatappfig{}

As an example, consider a scenario for a Chat application developed using AngularJS,
depicted in Figure~\ref{fig:chatapp}.
A system administrator of a \cb deployment would install the application, which give users the
ability to create application instances. To start a chat site, a user would create
an application instance and share its URL with chat participants.  As the participants join
the chat site, a virtual browser is created on demand for each participant, which is connected
to the application instance (the users can bookmark their virtual browser's URL to later return.)
The shared application instance data in such an application
consist of the chatroom(s), users and their associated messages.  The advantage of this design
is that AngularJS's dirty-checking mechanism will reflect updates to the shared instance data
in each virtual browsers' document automatically, thus ensuring that new message are broadcast
to each.

\subsection{Authentication}

When an application is enabled with authentication, the system will redirect
the user's request to a login page if it detects the user has not logged in
that application. The login page itself is implemented by creating a virtual
browser in the system login application. The login page provides two
authentication options: a local authentication option where the user's
credentials are stored in MongoDB; an OAuth~\cite{hardt2012oauth} option which
authenticate user via Google's openID. The user could submit his email address
and password directly in the login page  for local authentication option. Then
the system will find the matching record in the account table.   For the OAuth
option, the user clicks a \emph{Login with Google Account} link  to land on a
Goolge account authorization page. After the user authorizes \cb{} to access
his Goolge account information, Goolge will request \cb{}'s authentication
callback URL and \cb{} will get the user's email address.

After the user logs in using either mode, the system adds an entry of the
user's email address and the application's mount point in the user's session
(stored in MongoDB as well). That entry indicates the user has logged in the
application. Then the login page virtual browser is closed and the user is
redirected to  the URL he originally requested. The subsequent requests from
the user will pass the authentication check until the session expires or the
user logs out the application.


\subsection{Application Instantiation Strategy}
\label{sec:appinstantiation}

The application instantiation strategy specifies
how the application instance and virtual browsers are instantiated.

Application programmers can create CloudBrowser applications in the same way in which
they create the client-side portion of a client-centric application, using low or high level
JavaScript libraries such as jQuery~\cite{jquery} or AngularJS.  
A descriptor in the application's manifest describes 
their application's instantiation strategy.
The supported strategies include

\begin{description}

\item[singleAppInstance] The application supports only one instance and single virtual browser.
    All connected clients will share a single server-side document in this singleton - this can be
    used for applications that display data, such as a weather application. These applications will not
    typically react to user input and users do not need to be authenticated.

\item[singleUserInstance]  This application requires authentication to establish a
    user identity, which we provide through a local database as well as through external OpenID
    authentication.   In this mode, users may not create more than one virtual browser per
    application instance.  When a user accesses the application instance's URL, they will either
    be forwarded to their virtual browser or a virtual browser will be instantiated for them.

\item[multiInstance]
    Allows users to have multiple, separate virtual browsers connected to an application
    instance. For instance, a user may have to be in two separate chatrooms offered by one chat site.
    In those cases, the user has the largest flexibility, but will need to manage whether
    to join an existing virtual browser or create a new one when they visit the application instance
    - similar to the choice a user may have when deciding whether to navigate to a new site in
    an existing browser tab or open a new one.

\end{description}

Except for multiInstance applications, the existence of virtual browsers is not exposed to
end users that merely join existing application instances.


% The hierarchy that results from applications, application instances, and virtual browsers is
% depicted in Figure~\ref{fig:appidhierarchy}.  This figure shows the general case in which an
% application might allow multiple instances, and in which each user can create multiple virtual
% browsers.


