\chapter{nodermi: A Remote Procedure Call Framework for \nodejs{}}
\label{ch:rmi}
\markright{nodermi}
In the single process version of \cb,
everything lives in the same address space,
which allows application code to invoke system component's functionality.
As \cbtwo divides \cb into multiple processes,
some of those local method invocations need to be replaced by
inter-process communication,
because as the framework spreads its state
and responsibility to multiple processes,
an operation initiated in one process
could require access in state located in another process.
For example,
in the single process version,
closing a virtual browser
is implemented by invoking the close method of the virtual browser
object.
Now if the virtual browser is in another process
, closing it requires that a request be sent to that process.
We could have introduced new objects and methods to send specific messages.
This approach is undesirable for the following reasons.
First, there are many of method invocations that would need to be transformed.
In this way
we would have to design message format for many different types of methods and
write handler code to parse and process these messages.
Second,
since the continuous coding, including changes to existing methods.
We would need to modify the message communication layer continuously.
To avoid
boilerplate messaging code and allow code evolve,
we developed nodermi~\cite{nodermi}, an object-oriented
remote procedure call(RPC) framework for \nodejs{}.
% Nodermi hides the complexity of inter-process communication details from
% upper layer code and is adaptive to code changes.

Before we discuss the implementation of nodermi,
we first introduce some terms for nodermi and
RPC systems in general.
We use the term \emph{local object}
to refer objects that are local to calling process.
We use the term \emph{remote object} to represent objects that are
living on other processes.
We use \emph{stub} or \emph{remote reference} to refer to special objects created
by nodermi that represents \emph{remote object}s
(we can think \emph{stub}s as proxies to remote objects).
We say an object is \emph{remotely referenced} from a process
if there are \emph{stub}s representing it.
Each \emph{stub} represents one \emph{remote object},
it has methods that mirror the \emph{remote object}'s methods.
From the programmer's perspective,
\emph{stub}s are just like ordinary local objects.
When calling a \emph{stub}'s method, the underlying
RPC framework code sends messages to the \emph{remote object}'s process
to invoke the corresponding method there.
For a given object, the process that creates that object is referred
as \emph{host} of that object,
the process that holds a \emph{stub} representing
that object is called \emph{client},
the \emph{host} is also called \emph{server} to that \emph{client} process.
In \js{}, since functions are first class citizens, it is possible
to pass a function as a parameter or return a function as a result.
Nodermi treats functions and objects alike : functions could also be
\emph{remotely referenced}.


\section{Semantics}

\nodermiexamplefig{}

\paragraph{Synchronous Methods}
Unlike traditional RPC frameworks where the process blocks during the
completion of remote method~\cite{birrell1984implementing},
nodermi is fully asynchronous since \js{} functions may not block.
In nodermi a remote method call returns immediately after initiating the communication
similar to other IO related asynchronous methods.
Thus the result of the method on server
is not known when the stub method returns on client.
To get the result of a remote method,
the remote method should be implemented asynchronously,
that is passing result to caller via callback functions.
If a remote method is synchronous,
we need to change it to be asynchronous if
we want to wait for its result on the client side.


\paragraph{Passing Arguments}
When calling a remote method, the arguments are either
passed by reference, by value or by implementation to
the server process.

\paragraph{Pass By Value}
Simple objects that do not contain methods
 are passed by value.
In contrast to passing by reference,
the server side creates field to field copies of them instead of creating
stubs.

\paragraph{Pass By Implementation}
For some commonly used objects that have simple
internal states such as Dates, Errors, Byte Buffer, etc.,
nodermi passes them by implementation.
It is obvious that it makes little sense to remotely
call a method of a Date object if we could create
a local Date object with exactly the same value.
Nodermi implements passing by implementation by transmitting the internal
states of these objects to the receiving process and
calling constructors
of these objects in the receiving process with the internal states.
Besides built-in types,
nodermi also passes a customized object by implementation if
its constructor is registered and it implements a method
to export its internal states as constructor arguments.
Unlike similar features
 in other RPC frameworks~\cite{birrell1993distributed}~\cite{j2eedoc}
 where representation of the class definition is passed,
we assume the class definition of the object passed is presented
in the receiving process.


\paragraph{Pass By Reference}
When an object is passed by reference to another process,
nodermi creates a stub representing that object on the receiving process.
In this way,
the receiving process could remotely invoke methods of that object.
Functions are always passed by reference in nodermi.
For example, in figure~\ref{fig:nodermiexample}, the callback function
\emph{callbackA} is passed by reference. Nodermi creates
a stub \emph{stubCallbackA} representing it in \emph{Process B}.
\emph{Process B} then invokes \emph{stubCallbackA} like a local function.

\paragraph{Pass Stubs}
A stub is passed by reference. Unlike ordinary objects,
nodermi does not create a new stub to represent that old
stub.
Instead, if the stub represents an object on the receiving
process, nodermi will use that original object on the receiving
process directly.
Otherwise, nodermi creates a new stub represents
the remote object the old stub represents.
In this case, method invocation on the new stub will
initiate communication directly to the process that
hosts the original remote object.



\paragraph{Remote Object Property}
A stub's properties is a snapshot of the properties
of the remote object it represents.
Similar to passing method arguments,
properties are passed by value, implementation or reference
based on the their types.
We could read or write properties of a stub directly.
But the changes we made to a stub's property
will not be synchronized to the remote object the stub represents.
Vice versa,
changing the properties on the remote object has no effect
on the stub either.
It is ideal to make the stub acts like a regular reference
to the remote object such that
changes made on one side would be reflected on the other.
It is not feasible to implement this semantics because
in \js{} reading or writing object property is synchronous,
we cannot block to wait for synchronization takes place
 when accessing object property.
We could have intercept assignment to existing properties using
\emph{setter} and propagate the assignment to other processes.
We still cannot preserve the semantics of the local property assignment
where the property update takes effect right after the assignment statement returns.
Moreover, there is no way in \js{} to intercept the operation of
adding a new property or deleting a property.



\section{Design}

\nodermifig{}

Figure~\ref{fig:nodermi} is a diagram of nodermi's design.
A stub is created with every method pointing to the
\emph{remote method invocation} module in nodermi.
This module
first encodes the arguments of the method call
 and other necessary information about this method call
as a \emph{method invocation message}.
The transport layer then converts the message to
a binary string and sends it
to the server process.
On the server side, the transport layer first reads
the message from the network and invokes \emph{method invocation handler}.
The handler
constructs arguments by decoding the \emph{method invocation message},
it would create stubs to represent the original arguments in the client process
 if necessary,
then invokes the corresponding local method with the arguments
it constructs earlier.

Nodermi uses TCP sockets to implement inter-process communication,
a process needs to allocate a TCP port and specify a host name
to receive incoming nodermi messages.
Since the host name and port for nodermi is unique for every process,
nodermi uses them as the process's identifier.
When a object is passed by reference to another process,
a unique object id is assigned to that object,
the stub created in the receiving process
will contain the object id and the sending process's identifier.
So when we call a stub's method,
nodermi could find the right process and object using
the information stored in the stub.

\paragraph{Bootstrap}
It is clear that nodermi automatically creates stubs during
passing arguments in remote method invocation without programmers
explicitly calling framework API.
However, the first \emph{stub} cannot be obtained
via remote method invocation.
Nodermi provides \emph{retrieveObj} API to get
a stub directly.
The programmer needs to provide a remote process's identifier
and an object name for this API.
The remote process will locate an object that has been registered
using the exact object name via \emph{registerObj} API,
and pass that object to the requesting process by reference.


Let's explain the message flow with the example
in Figure~\ref{fig:nodermiexample}.
As shown in the code snippet on the top left of the figure,
process A invokes \emph{method1} with a function argument \emph{callbackA}.
First nodermi creates a \emph{method invocation message}
contains information about the remote method being called:
the object ids of \emph{method1} and \emph{objB}.
The message also contains information about the arguments:
the object id of \emph{callbackA} and
the type of \emph{callbackA}.
After process B receives the message,
it reconstructs the arguments for the method call,
that is creating a stub for \emph{callbackA}.
The stub \emph{stubCallbackA} is a function and
it stores \emph{callbackA}'s id and Process A's process identifier.
Then process B finds \emph{objB} and \emph{method1} using the
object ids in the message.
After that,
process B invokes the \emph{method1} with \emph{stubCallbackA} as argument.
The \emph{method1} then invokes \emph{stubCallbackA} with \emph{result}.
Finally, \emph{callbackA} in process A
is invoked via a remote method call from process B.
% Notice that the variable \emph{result} is not necessary B's local object,
% it could be a stub reference to an object



\section{Distributed Garbage Collection}
\js{} relies on garbage collection to reclaim memory taken by
objects that are not referenced anymore in the program.
However, the garbage collector is not aware a local object
could also be referenced by another process through nodermi.
In the example shown in Figure~\ref{fig:nodermiexample},
after \emph{method1} of \emph{stubB} is called,
\emph{callbackA} is out of scope in process A,
it is not referenced anymore by the user code.
If nodermi does not hold reference to \emph{callbackA},
it could be garbage collected before it is invoked.
In fact, in practice callback functions like \emph{callbackA} are almost
immediately garbage collected because it is likely that these functions
live on the new space of a generational garbage collector heap that is frequently
garbage collected.
However, if we naively keep reference to objects like
 \emph{callbackA} in nodermi,
our application is surely prone to memory leak
as objects that are once remotely referenced
will never be garbage collected even after the local and remote processes
no longer use them.
Setting a timeout to automatically clean references of
these objects from nodermi is not going to work either,
since there is no guarantee that when the client is going to use a
particular object.
For example,
when a process registers a listener function to a remote event publisher,
the listener could be remotely triggered at anytime in the future.


There are a lot of research related to garbage collection in a distributed
environment~\cite{abdullahi1998garbage}, ~\cite{birrell1993distributed}.
We designed a mechanism that is similar to the sequence reference counting algorithm
designed by Birrell et al.~\cite{birrell1993distributed}.
We will discuss the difference between our work and ~\cite{birrell1993distributed}
in section~\ref{sec:relatedrpc}.

The high level design of our distributed garbage collecting
algorithm works as follows.
For each process, nodermi has an object map containing the objects
that are still remotely referenced.
The object map prevents garbage collector from prematurely garbage collecting
these objects by holding references to them.
This map is also necessary for looking up local objects
when handling \emph{method invocation} messages.
On the other hand, nodermi holds weak references(implemented using node-weak~\cite{nodeweak})
to \emph{stub}s.
Garbage collector could collect objects that are only
referenced by weak references.
When a stub is not used, it would be garbage collected,
then a callback function which is registered when creating
the stub's weak reference is fired to
send the stub's host process a \emph{dereference message}.
Upon receiving a dereference message,
nodermi knows that a remote reference to a local object
is now defunct.
In this way, an object could be removed from the object map after
all of the stubs representing it being garbage collected.
At this point, if it is not referenced locally it could
be safely garbage collected.


\nodrmiobjmapfig{}

Figure~\ref{fig:nodermiobjmap} shows the structure of
the object map and the stub map
where nodermi stores weak references to stubs.
The object map contains the local objects and information of
their remote references.
A remote reference is represented by a session id,
a unique id generated by nodermi every time it transmits objects
to remote processes.
When a local object is transmitted, the current session id is added to
the object map indicating a new remote reference is created.
On the receiving side, the session id is written to
the \emph{stub}s created in this transmission.
When a \emph{stub} is garbage collected,
the \emph{dereference message} will contain
the remote object's id and the session id stored
in the stub.


So far, we only considered the scenario of a process sending its local
objects to another process.
It is also possible that a process could send a \emph{stub} to another process.
If the \emph{stub}'s host is the receiver, then there is no problem because no remote
reference is created.
If the \emph{stub}'s host is not the receiver(it could not be the sender either),
then a record needs to be added to the host's object map to indicate
a new remote reference.
In this situation,
the sender process first sends a \emph{reference message} to
ask the host
to generate a new session id
and put that session id into the host's object map.
After that,
the sender will send the \emph{stub} and the new session id
to the receiver.
By the time the receiver gets the message from the sender
and
creates a new \emph{stub} to the original object,
the host already has the record of this new remote reference.

A process could terminate without explicitly releasing its remote references
by sending dereference messages.
This could create false remote references on other processes.
To remove these false remote references,
nodermi cleans a remote process's records in the object map if
it detects that remote process is terminated.
Nodermi keeps a table of last response time of remote processes it contacted,
it updates the table every time it receives a message from a remote process.
When the table entry for a process is not updated for more than 60 seconds, nodermi
will send a ping message to that process.
If the ping message is unanswered, all records of that process will be removed
from the object map.
This feature ensures that a terminated process will not cause memory leak on
other processes.




% FIXME comparison

% semantics of properties, methods, this  field accesses, object identity
% caja, druby, javascript , python

% \section{Issues}

% async
% network partition, transmission failure, server restart