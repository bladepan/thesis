\chapter{nodermi: A Remote Method Invocation Library for \nodejs{}}
\markright{nodermi}

Masters and workers need to communicate with each other.
We developed nodermi~\cite{nodermi}, a remote method invocation(RMI) library to
to hide the complexity of interprocess communication away from
programmers.
% pic

We use the term \emph{local object}
to refer a object that is created by the process in context.
We use the term \emph{remote object} to represent a object that is
created by other processes.
We use \emph{stub} to refer to a special object that is created
by nodermi or other remote method invocation system that
acts like a proxy to a \emph{remote object}.
In \js{}, function is the first class citizen, it is legal
to pass a function as a parameter or return a function as a result.
So we will use the term object to refer to orthodox objects as well as
functions unless specially noted.
For a given object, the process that creates that object is referred 
as \emph{host} or \emph{sever}, 
the process that holds the \emph{stub} to that object is called \emph{client}.


\section{Usage}
First, the developer needs to create a nodermi instance by passing a configuration
object to a factory method.
The nodermi instance will listen on a TCP port as specified in the configuration
to accept messages from other nodermi instances.
The nodermi instance provides three public methods : \emph{createSkeleton},
\emph{retriveObj}, and \emph{close}.
The \emph{createSkeleton} method allows the developer to register local objects
with names.
The \emph{retriveObj} method fetch a remote object on another process by name.
The \emph{close} method shuts down the nodermi instance.

Usually, the developer would expose several service objects to other process
by \emph{createSkeleton} method.
These service objects often serve as bootstrapping points for clients.
The client could obtain these objects by \emph{retriveObj},
it could fetch even more server side objects or passing its own objects to server
by calling methods on these service objects.
In the upper layer of the application code,
there is no distinction of a local object and a remote object stub,
the developer does not need to write any code explicitly calling nodermi.

% desc list browser ...
In \projectname{}, we use nodermi extensively. 
For example, in the administrator dash board application, 
we need to list all the application instances of a given application,
we would also want to list all the virtual browsers of a given application instance,
we also need the option to shut down an application instance or a virtual browser.
It is unlikely that the worker node that is executing these logic would contain
all the application instances.
Instead of designing internal message protocols for all the necessary
operations we want to have and writing communication code all over 
the place, 
we could grab stubs of all the application instances by a method call
to the stub of an master's application object, 
and we could also grab stubs of virtual browsers by calling a method 
on the application instance stubs.
We do not have to add a lot of code because we only need to 
implement necessary logic on the corresponding classes,
nodermi takes care of all the communication.

\nodermifig{}

\section{Design}
Figure~\ref{fig:nodermi} is a diagram of nodermi's design.
A stub is created to have the same set of properties and methods as the remote object
it represents.
Nodermi adds a few hidden fields in the stub such as the host of the remote object,
and the id of the remote object.
The stub's methods are pointing to a nodermi's internal method,
let's call it \emph{invoke remote}.
When the process calls a stub's method, 
it essentially calls nodermi's \emph{invoke remote} method. 
In \emph{invoke remote}, nodermi first serialize the parameters passed
to the method.
Then nodermi constructs a \emph{method invocation} message that contains
the serialized parameters.
Finally, nodermi sends the message via the transportation layer.
On the other side, when nodermi receives a \emph{method invocation} message,
the \emph{method invocation handler} will finish the job of remote method invocation.
In the \emph{method invocation handler},
nodermi extracts serialized parameters and pass it to decoder.
For each parameter,
the decoder either creates a stub if it is remote to this process,
or locate a local object if it points to a local object.
The reason that a parameter from a remote site could point to a local object is that,
we have no restriction as how stubs could be used in the code, 
a stub could be used as a parameter or be returned as a result of a method.

\nodrmimethodinvokefig{}
\nodrmicallbackfig{}

Figure~\ref{fig:nodermimethodinvoke},~\ref{fig:nodermicallback} shows a simple example
of a remote method invocation. 
In these two figures, process B hosts a object \emph{objB} that has a method called \emph{method1},
suppose process A has a stub represents \emph{objB} called \emph{stubB}.
As shown in the code snippet on the top left of Figure~\ref{fig:nodermimethodinvoke},
process A invokes \emph{method1} with a parameter which is a function named \emph{callbackA}. 
The implementation of \emph{method1} is shown on the top right of the figure,
\emph{method1} first call another function and store the return value to variable \emph{result}, 
then it calls its own parameter \emph{callback} with \emph{result} as the second parameter
of \emph{callback}.
The implementation of \emph{callbackA} is just print out the second parameter it receives.
It is common practice in \js{} that a function does not send its result to the caller using ``return'' 
statement,
instead it accepts a callback function from the caller as a parameter 
and pass the result to that callback function.
The callback function could be invoked synchronously or at some other time in the future.
It is also  
common practice that the first parameter of a callback function is reserved for errors.
In our example, \emph{method1} adopts those common idiom to ``return'' its result.
Conceivably, if \emph{objB} lives on the process A, calling \emph{method1} with
\emph{callbackA} would directly print out \emph{result}.
In our example, calling \emph{stubB}'s \emph{method1} will invoke nodermi to 
encode the \emph{callbackA} and send a \emph{method invocation} message to process B.
In process B, nodermi finds out process A wants to execute \emph{method1} and
there is a function parameter, 
then nodermi realizes the function parameter is living on process A,
so it creates a stub \emph{stubCallbackA} to represent \emph{callbackA} and pass
\emph{stubCallbackA} to \emph{method1}.
In Figure~\ref{fig:nodermicallback}, 
\emph{method1} calls \emph{stubCallbackA} with the \emph{result} variable,
\emph{result} is serialized by nodermi and a \emph{method invoke} message is sent
by process B to process A, finally, \emph{callbackA} on process A is invoked.
In the whole process, there is no difference for the programmer that \emph{nodeB}
is on process A or not.

\section{Encode and Decode}
Nodermi encodes the parameters of remote method calls as well as
the result of API \emph{retirveObj} to a format called object descriptor
before transmission.
The object descriptor for a object includes a id which is unique
among all the local objects created by its host process.
For regular objects, the object descriptor also includes
its host process's identifier, the object descriptors of its properties and methods.
The object descriptor for a function includes
its id and its source process's identifier and port as well.

The object's id is assigned during the encoding process, the id is written to the object
using a hidden field so the same object will not be assigned with different ids.
Nodermi also handles cyclic references by encoding cyclic reference as a special \emph{ref}
type.

Nodermi use several policies to minimize the size of object descriptors:
if the object is a local object, then process identifier will be ignored 
in the object descriptor because the receiving site could infer these values;
if the object is a stub represents an object from the destination,
nodermi will not write its properties and methods in the object descriptor 
because the receiving site has the original object;
simple structured objects that has no methods are treated as
ephemeral objects, they are encoded directly using JSON representation; etc.

By default, the encoder of nodermi ignores properties and methods inside 
an object that has a prefix of `\_', 
because by conversion these are private.
Programmers can also explicitly tell should nodermi skip or include 
certain properties or methods during encoding by assign 
``\_\_r\_skip'' or ``\_\_r\_include'' property.

The decoding process creates stubs or find local objects based on
the object descriptors received.

\section{Distributed Garbage Collection}
\js{} relies on garbage collection to reclaim memory used by 
objects that are not used anymore in the program.
However, the garbage collector does not aware a local object
could also be referenced by another process through nodermi.
In the example shown in Figure~\ref{fig:nodermimethodinvoke},
after \emph{method1} of \emph{stubB} is called, 
\emph{callbackA} is out of scope in process A, 
it is not referenced anymore by any application code.
If nodermi does not hold reference to \emph{callbackA},
it could be garbage collected before it is invoked in Figure~\ref{fig:nodermicallback}.
In fact, in practice the callback function like \emph{callbackA} is almost
immediately garbage collected because it is likely that \emph{callbackA}
lives on the new space of a generational garbage collector heap that is frequently
garbage collected.
However, if we naively keep reference to the \emph{callbackA} in nodermi,
our application is surely prone to memory leak as objects like \emph{callbackA}
will never be garbage collected.
Setting a timeout for these references is not going to work either,
there is no guarantee that when the stub is going to be used,
for example, a process could register a function to be invoked when
a remote event happens and the event could happen in arbitrarily moment in the future.

There are many researches related to garbage collection in a distributed
environment~\cite{abdullahi1998garbage}, ~\cite{birrell1993distributed}.
We designed a mechanism that is similar to the sequence reference counting algorithm 
of Birrell et al.~\cite{birrell1993distributed}.
We will discuss the difference between our work and ~\cite{birrell1993distributed}
in this section.

For each process, nodermi keeps a map of the objects that clients still hold
their \emph{stub}s. 
The map could prevent garbage collector from prematurely garbage collecting
these objects by creating strong references to them.
This map is also necessary to look up for local object when handling \emph{method invocation} messages.
Nodermi also holds a map of \emph{stub}s it created using weak reference.
We use a \nodejs{} package called node-weak~\cite{nodeweak} to implement weak reference.
Unlike regular reference, the garbage collector could collect an object if it is only
referenced by weak reference.
The node-weak package provides a way to register a callback function which will
be executed when the object is garbage collected.
When a new \emph{stub} is created, nodermi creates a new weak reference to 
the \emph{stub} and register a callback function to the weak reference,
then the upper layer code get the strong reference of the \emph{stub}.
When \emph{stub} is not referenced anymore, 
the callback will be executed to send a dereference message to the server.
After the server receives dereference message from all the clients of a object,
the object is removed from object map and is subject to garbage collector.


\nodrmiobjmapfig{}

Nodermi creates new \emph{stub} object for a remote object every time
the process obtains a new reference to that object.
This design choice greatly simplifies the implementation of nodermi decoder and
the communication between processes.
To differentiate the \emph{stub}s for the same remote object, 
nodermi generate session id each time it invokes the encoder.
Because the host needs to remember the remote references for a local object,
a local object is wrapped in a reference object before it is put into the object map.
When the host encodes a local object,
the current session id is added to the object's reference object.
On the other side, 
the client will write the session id as a hidden property of the \emph{stub}.
As in Figure~\ref{fig:nodermiobjmap}, the object map hods reference to 
the local objects that still has remote references, 
the remote references are recorded as a list of session ids,
the \emph{stub} map holds weak references to \emph{stub} objects,
multiple \emph{stub}s could point to the same remote object.
Whenever a \emph{stub} is garbage collected,
the callback registered in the weak reference is fired to send a dereference message
to the host.
The dereference message includes the object's id and the \emph{stub}'s session id.
When the host receives a dereference message, it removes a session id record from 
a corresponding reference object.
When a reference object has no session ids left, it is removed from the object map.
After that, the underneath local object could be garbage collected.
In this design, a local object will not be garbage collected if there is
remote reference, and it is at the disposal of garbage collector once there is
no local or remote reference to it.

\nodrmiracefig{}

The reason why we record every remote reference of a object is manifold.
First, let's assume we only record the remote reference in the process level,
that is recording only the process identifier of a remote reference.
Consider the case in Figure~\ref{fig:nodermirace},
Process A reference remote object \emph{objB} twice,
the host Process B receives a dereference message 
after it sends out the second reference to \emph{objB},
so \emph{objB} could be garbage collected even process A still holds a remote
reference.
One way of fixing this is that
the client needs to send a message to the host before creating the \emph{stub},
and the server makes sure the remote object's reference record contains the client.
In this case, the client should create only one \emph{stub} per remote object,
so the client needs proper synchronization between invocation of decoders to
avoid creating duplicate \emph{stub}s. This is basically the implementation 
of ~\cite{birrell1993distributed}. %TODO


So far, we only considered the scenario that a process sending its local
objects.
It is also possible that a process would send a \emph{stub} to another process.
If the \emph{stub} is from receiver, than there is no problem because no remote
reference is created.
If the \emph{stub} is not from receiver(it cannot from the sender),
then we need one more type of messages.
When a process is sending a \emph{stub} that is not from the receiver,
it will first send reference message to the host to ask the host
to generate a new session id and put that session id into its object map,
after that, the sender will put the session id in the object descriptor of that 
stub and send to the receiver,
the receiver will create a \emph{stub} with the new session id.
This grantees the remote object will not be prematurely garbage collected 
because if the new remote reference is created in the receiver,
the object is surely held in the object map,
and it will not be removed before the new \emph{stub} becomes garbage.


\section{Semantics}
For a remote stub, only method calls are forwarded to the server,
local change to the properties has no effect on the server,
nor the server's update to the properties will be synchronized to the clients.
The remote stub is a snapshot of the state of the remote object before it is sent.

For remote method calls, the return value is not defined. 
That is because \js{} code runs on a single thread, so we should not block
a remote method call to wait for the server side to return.
The method on the server side will still be invoked, 
but its return value is ignored.
The client could get result of a method call 
from server via callback functions like in Figure~\ref{fig:nodermimethodinvoke}.
So refactoring is necessary if the caller needs the result and 
the original method does not accept callback function.

In \js{}, reading or writing properties is synchronous. 
Although we can intercept writing existing properties of a stub using
\emph{setter}, we could not make these operations non-blocking if we decided to update
the remote object as well.
Vice visa, we cannot synchronize the properties of remote object with its clients without
blocking the access to properties.
Moreover, there is no way in \js{} to intercept the operation of adding a new property or delete 
a property.
So the property manipulations only take effect locally.

In some remote object systems~\cite{birrell1993distributed},
the client can read or write properties of remote stubs via their methods.
We think this behavior unacceptable in our system.

% FIXME comparison

% semantics of properties, methods, this  field accesses, object identity
% caja, druby, javascript , python

\section{Issues}

% async 
% network partition, transmission failure, server restart