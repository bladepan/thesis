\chapter{nodermi: A Remote Procedure Call Framework for \nodejs{}}
\label{ch:rmi}
\markright{nodermi}

As we develop \cbtwo on the code base of a single process design,
many former method invocations need to be transformed to inter-process
communication.
For example, the new framework should be able to manipulate
virtual browser on any worker process, 
in the single process version, 
these operations are implemented by method invocations of a virtual browser
object since everything is in a same process,
now these operations need to be implemented as inter-process
communication if the virtual browser is on another process.
A straightforward approach is
designing message protocols for these methods and
replacing the method invocation with explicit message sending.
We do not take this approach for the following reasons.
First, there are a lot of method invocations need to be transformed.
We need to design message format for many different types of methods and
write handler code to parse and process these messages.
Second, we are constantly changing existing methods and add
new methods to objects.
We need to modifying the message communication layer 
when we make these changes.
Third, 
we want to reuse the existing code as much as possible.
Using explicit message passing would change the existing code base completely.
To deal with our concerns with explicit message communication,
we developed nodermi~\cite{nodermi}, an object-oriented
remote procedure call(RPC) framework for \nodejs{}.
% Nodermi hides the complexity of inter-process communication details from
% upper layer code and is adaptive to code changes.

Before we discuss the implementation of nodermi,
we first introduce some terms for nodermi and 
RPC systems in general.
We use the term \emph{local object}
to refer objects that are local to the process.
We use the term \emph{remote object} to represent objects that are
living on other processes.
We use \emph{stub} or \emph{remote reference} to refer to special objects created
by nodermi or other RPC framework that
represents \emph{remote object}s(you can think \emph{stub}s as proxies to remote objects).
Each \emph{stub} represents one \emph{remote object}
and a \emph{stub} has methods represent
its \emph{remote object}'s methods.
We say an object is remotely referenced if there are \emph{stub}s representing 
it. 
When calling a \emph{stub}'s method, the underlying
RPC framework code is executed to send messages
to its \emph{remote object}'s process
to invoke the corresponding method there.
In \js{}, function is the first class citizen, it is legal
to pass a function as a parameter or return a function as a result.
We use the term object to refer to ordinary objects as well as
functions unless explicitly noted.
Similarly, since a function could exist without being part of an object,
when we talk about method and method invocation in \js, 
the term \emph{method} means a member function of an object
or a standalone function.
For a given object, the process that creates that object is referred
as \emph{host} of that object,
the process that holds a \emph{stub} to that object is called \emph{client},
the \emph{host} is also called \emph{server} to that \emph{client}.
There is no clear distinction between \emph{server} and \emph{client},
it depends on the context of which object is under discussion.



Nodermi encapsulates inter-process communication via \emph{stub}s.
From the description above, we could see that
calling methods of \emph{stub}s is equivalent to calling methods
on their \emph{remote object}s.
From the upper layer code, \emph{stub}s are just like ordinary local objects.
Nodermi automatically create new \emph{stub}s in the process
 of remote method invocation.
For example, once you get a \emph{stub} for a remote application instance object,
you can get \emph{stub}s of its virtual browser objects by calling
\emph{list browsers} method of the application instance \emph{stub}.
Thus, the object oriented structure of the original single process code could
be preserved.
A process only need to explicitly register a few entry point objects to nodermi 
so other processes could get initial \emph{stub}s.
In our system, the master registers its application management object in nodermi.
A worker would first get \emph{stub} of the master's application management object.
Then the worker could register its application instance to master 
via a method call on the \emph{stub}.
On the master side, a \emph{stub} to the application instance is created and
stored in the master's application instance table.
The worker could also obtain \emph{stub}s to application instances on other workers by 
calling a method on the its \emph{stub} to master's application management object.
The worker could then directly communicate to other workers
by calling methods on the newly created \emph{stub}s 
even it does not have other workers' addresses in configuration.

One thing worth noting is that in \nodejs anything involves IO
needs to be asynchronous. 
Obviously, remote method invocation involves IO.
It is unrealistic for nodermi to block the execution thread to wait
for a remote method finishes.
That means, methods can only ``return'' value to clients via
callback functions.

% pic


\nodermifig{}

\section{Design}
Figure~\ref{fig:nodermi} is a diagram of nodermi's design.
A stub is created with every method pointing to the 
remote method invocation code in nodermi.
When a method of a stub is called,
nodermi encodes the parameters and some information of this method 
into a method invocation message.
The transportation layer then converts the message into 
a binary format and sends to the host of the stub's remote object.
On the server side, the transportation layer first reads 
the message from the network and invoke \emph{method invocation handler}.
The handler finds the local object which the \emph{stub}
represents,
finds the local object's method which this invocation is about,
decodes the message to reconstruct the parameters of this method call,
then call the method with the decoded parameters.


Nodermi uses TCP sockets to implement inter-process communication,
so each process needs to assign host and port for nodermi.
Since each process would have a different host port pair for nodermi,
nodermi uses these host port pairs as process identifiers.
Nodermi also assigns a unique id for every local object it has processed.
A stub stores its remote object's id and process identifier of its remote object's host.
That's how nodermi could find host processes for remote objects and
find the local objects for remote method invocation.

To get a initial \emph{stub}, a process 
calls \emph{retrieveObj} API with a remote process's identifier and 
an object name.
The remote process needs first register a local object with that name by
\emph{registerObj} API.
Programmers need to explicitly calling nodermi for the initial \emph{stub}s,
nodermi will automatically create new \emph{stub}s for method parameters.


We create a separate layer for transportation component to decouple network
IO from other nodermi logic.
The transportation component serialize and de-serialize message objects
and manages network communications.
Right now we use data exchange protocol ProtoBuf~\cite{protobuf} to convert message objects to binary
formats and send the binary data on long running TCP connections.



\nodrmimethodinvokefig{}
\nodrmicallbackfig{}

Figure~\ref{fig:nodermimethodinvoke},~\ref{fig:nodermicallback} shows a simple example
of a remote method invocation.
In these two figures, process B has a local object \emph{objB} that has a method called \emph{method1},
suppose process A has a stub representing \emph{objB} called \emph{stubB}.
As shown in the code snippet on the top left of Figure~\ref{fig:nodermimethodinvoke},
process A invokes \emph{method1} with a parameter a function named \emph{callbackA}.
First nodermi will create a method invocation message.
The message contains information about the remote method being called:
the ids of \emph{method1} and \emph{objB}.
The message also contains information about the parameters:
the id of \emph{callbackA} and the type of \emph{callbackA} is a function.
After process B receives the message,
it reconstructs the parameters for the method call,
that is creating a stub for \emph{callbackA},
the stub is a function like the original \emph{callbackA} and 
stores \emph{callbackA}'s id and Process A's process identifier,
we denote this stub as \emph{stubCallbackA}.
Then process B finds \emph{objB} and \emph{method1} by the ids in the message.
After that,
process B invokes the \emph{method1} with \emph{stubCallbackA} as parameter.
The \emph{method1} then invokes \emph{stubCallbackA} with \emph{result}.
In Figure~\ref{fig:nodermicallback}, \emph{callbackA} is invoked
via a remote method call by process B,
and the result computed in process B is printed in process A.
In the whole process, there is no difference for the programmer that \emph{objB}
is in process A or not, the code just passes objects around using plain method calls.
% Notice that the variable \emph{result} is not necessary B's local object,
% it could be a stub reference to an object


\section{Encode and Decode}
As we mentioned earlier, nodermi assigns ids for local
objects that are referenced remotely.
An object id is written to the object in a hidden field
so an object's id remains the same throughout the lifetime of the process.
When creating a stub,
the host process's identifier as long as the remote object's id
are written in hidden fields of the stub.
To avoid conflict with user defined fields, these hidden fields are prefixed
with ``\_\_r'' and they are not enumerable or modifiable.

By default nodermi encodes the whole object graph of an object recursively.
Each property of an object is encoded 
as an object descriptor with its property name.
An object descriptor contains an object's id, its process descriptor,
its type and a list containing its encoded properties.
Cyclic reference is handled by encoding cyclic reference as
a special reference object with no properties.
Nodermi assumes properties with ``\_'' prefixed names are private
 and omit them during the encoding.
Nodermi also allows programmers to explicitly specify properties
to include or skip in encoding by assigning predefined fields 
with property names.

The decoder reconstruct parameters based on the information provided by the client's encoder.
When creating a stub object,
all the properties of its remote object specified in the message 
are decoded recursively.
Simple properties like numbers or strings are directly set in the stub.
For methods, stub methods are created. 
For object property, new stubs are created.

% better connection here
Nodermi adopts several policies to minimize the size of messages:
When encoding objects of type Error, Date and Buffer,
only the value of these objects are encoded,
and they are decoded as new local objects instead of stubs,
because it makes little sense to invoke remote method call for these objects.
When encoding a stub that references an object from the receiver,
the properties are omitted, only object id and a type string indicating 
it is from the receiver are encoded,
the receiver would decode this object as the original local object.
Objects of Socket type are discarded entirely, because
there is little reason that a socket should be exposed as a remote object.
Methods inherit from Object class are omitted like ``toLocaleString''
and ``toJSON'', because it makes no sense to call these methods remotely.
For similar reasons, 
more objects and methods could be omitted or specially encoded
in the future.


\section{Distributed Garbage Collection}
\js{} relies on garbage collection to reclaim memory taken by
objects that are not referenced anymore in the program.
However, the garbage collector is not aware a local object
could also be referenced by another process through nodermi.
In the example shown in Figure~\ref{fig:nodermimethodinvoke},
after \emph{method1} of \emph{stubB} is called,
\emph{callbackA} is out of scope in process A,
it is not referenced anymore by the user code.
If nodermi does not hold reference to \emph{callbackA},
it could be garbage collected before it is invoked in Figure~\ref{fig:nodermicallback}.
In fact, in practice callback functions like \emph{callbackA} are almost
immediately garbage collected because it is likely that these functions
live on the new space of a generational garbage collector heap that is frequently
garbage collected.
However, if we naively keep reference to the \emph{callbackA} in nodermi,
our application is surely prone to memory leak as objects that are once remotely
referenced
will never be garbage collected even when local or remote processes no longer hold their reference.
Setting a timeout to automatically clean these objects from nodermi
 is not going to work either,
there is no guarantee that when the remote site is going to use the object.
For example,
a stub to a listener function could be stored in a remote process
to be invoked when a event in the remote process happens,
the event could happen multiple times in arbitrarily moments in the future.


There are a lot of research related to garbage collection in a distributed
environment~\cite{abdullahi1998garbage}, ~\cite{birrell1993distributed}.
We designed a mechanism that is similar to the sequence reference counting algorithm
of Birrell et al.~\cite{birrell1993distributed}.
We will discuss the difference between our work and ~\cite{birrell1993distributed}
in section~\ref{sec:relatedrpc}.

The high level design of our distributed garbage collecting 
algorithm works as follows.
For each process, nodermi has an object map containing the objects 
that are still remotely referenced.
The object map prevents garbage collector from prematurely garbage collecting
these objects by creating references to them.
This map is also necessary for looking up local objects 
when handling \emph{method invocation} messages.
An object is removed from the map once its stubs
are no longer needed by clients.
Intuitively,
when a stub is no longer needed by a client,
the stub is good to be garbage collected by the client process.
Nodermi creates weak references(implemented by node-weak~\cite{nodeweak}) 
to the \emph{stub}s it creates
and hands regular references to the upper layer code.
Weak reference will not keep the underlying object alive
if the object is only referenced by weak references.
So when a \emph{stub} is not used anymore,
it would be garbage collected,
then a callback function that we registered when creating the weak
reference will be fired,
the callback function sends a dereference message to notify the server
a remote reference is ineffective.


\nodrmiobjmapfig{}

Figure~\ref{fig:nodermiobjmap} shows the structure of
the object map and the stub map where nodermi stores weak references to stubs.
The object map contains the local objects and information of
their remote references.
A remote reference is represented by a session id,
a unique id generated by nodermi every time it invokes encoder.
When a local object is encoded, the current session id is added to 
the object map.
On the client side, the session id is stored in the stub for that object.
When a \emph{stub} is garbage collected,
a dereference message with the object id and session id will 
be sent to the server side.


\nodrmiracefig{}

% using reference counter is useless because process A only
% has one reference to stubB even objB is sent multiple times

It is notable that 
unlike RPC systems 
where only one \emph{stub} is created for one object per client,
nodermi creates a new \emph{stub} for a remote object every time
the process obtains a new reference to that object.
We use this design because it
greatly simplifies the implementation of nodermi decoder and
the communication between processes.
Let's assume we create one \emph{stub} for one object per client.
Consider the case in Figure~\ref{fig:nodermirace},
Process A reference remote object \emph{objB} twice,
the host Process B receives a dereference message
after it sends out the second reference to \emph{objB},
so \emph{objB} could be garbage collected even process A still holds a remote
reference.
One way of fixing this is that
the client needs to send a message to the host before creating the \emph{stub},
and the server makes sure the remote object's reference record contains the client.
In this case, the client should create only one \emph{stub} per remote object,
so the client needs proper synchronization between invocation of decoders to
avoid creating duplicate \emph{stub}s. This is basically the implementation
of ~\cite{birrell1993distributed}. %TODO


So far, we only considered the scenario that a process sending its local
objects to another process.
It is also possible that a process would send a \emph{stub} to another process.
If the \emph{stub}'s host is receiver, than there is no problem because no remote
reference is created.
If the \emph{stub}'s host is not receiver(it could not be the sender either),
then 
a reference record needs to be added to the host's object map.
In this situation,
the sender process will first send a reference message to 
ask the host
to generate a new session id for a new remote reference
and put that session id into the host's object map,
after that, 
the sender will encode the \emph{stub} with the new session id
and send to the receiver.
When the receiver receives the message and
creates a new \emph{stub} to the original object on host,
the host already has the record of this new remote reference.


Nodermi also remove a remote process's references to local objects if
it detects that remote process is terminated.
Nodermi keeps a table of last response time of remote processes it contacted,
it updates the table every time it receives a request or a response from a remote 
process. 
When the table entry for a process is not updated for more than 60 seconds, nodermi
will send a ping message to that process.
If the ping message is unanswered, all references of that process will be removed
from the object map.
This strategy ensures that a terminated process will not cause memory leak on
other processes.

\section{Semantics}

For pragmatic reasons,
we do not implement \emph{stub}s to have the same semantics
as local references.
For a stub, only method calls are forwarded to the server,
changes made to the properties of a stub have no effect on the remote object.
Vice versa, the server's update to the properties of a local object will 
not be synchronized to its stubs either.
The stub's properties are merely a snapshot of the state of 
the remote object when it is encoded.
In \js{}, reading or writing properties is synchronous.
Although we can intercept writing existing properties using
\emph{setter}, we could not make these operations non-blocking if we decided to 
synchronize the changes to other processes.
Moreover, there is no way in \js{} to intercept the operation of adding a new property or delete
a property.

Some RPC systems~\cite{birrell1993distributed} only expose methods in stubs.
In these systems the developers can only read or write a remote object's
non method properties through methods.
Nodermi does not adopt this strategy because it puts limitations on the
application layer and it introduces more network round trips.
For example, in \js{}, it is common practice to call a method with
a container object that wraps simple value parameters and callback parameters,
the method would read parameters from the container object and invoke callback
extracted from the container object.
If we only expose methods for remote objects, we would need to define several 
getter methods for these container objects, 
and the code that reading properties of the container objects
needs to be replaced with to asynchronous getter method calls.
It would greatly complicate development not to mention the performance penalty.


As mentioned before, 
all remote method calls are asynchronous,
so the return value of remote method calls are not defined.



% FIXME comparison

% semantics of properties, methods, this  field accesses, object identity
% caja, druby, javascript , python

% \section{Issues}

% async
% network partition, transmission failure, server restart