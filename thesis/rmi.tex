\chapter{nodermi: A Remote Procedure Call Framework for \nodejs{}}
\label{ch:rmi}
\markright{nodermi}
In the single process version of \cb, 
everything lives in the same address space,
which allows application code to invoke system component's functionality.
As \cbtwo divides \cb into multiple processes,
some of those local method invocations need to be replaced by 
inter-process communication,
because as the framework spreads its state 
and responsibility to multiple processes,
an operation initiated in one process
could require access in state located in another process.
For example, 
in the single process version, 
closing a virtual browser
is implemented by invoking the close method of the virtual browser
object.
Now if the virtual browser is in another process
, closing it requires that a request be sent to that process.
We could have introduced new objects and methods to send specific messages.
This approach is undesirable for the following reasons.
First, there are many of method invocations that would need to be transformed.
In this way
we would have to design message format for many different types of methods and
write handler code to parse and process these messages.
Second, 
since the continuous coding, including changes to existing methods.
We would need to modify the message communication layer continuously.
To avoid 
boilerplate messaging code and allow code evolve,
we developed nodermi~\cite{nodermi}, an object-oriented
remote procedure call(RPC) framework for \nodejs{}.
% Nodermi hides the complexity of inter-process communication details from
% upper layer code and is adaptive to code changes.

Before we discuss the implementation of nodermi,
we first introduce some terms for nodermi and 
RPC systems in general.
We use the term \emph{local object}
to refer objects that are local to calling process.
We use the term \emph{remote object} to represent objects that are
living on other processes.
We use \emph{stub} or \emph{remote reference} to refer to special objects created
by nodermi that represents \emph{remote object}s 
(we can think \emph{stub}s as proxies to remote objects).
We say an object is \emph{remotely referenced} from a process
if there are \emph{stub}s representing it.
Each \emph{stub} represents one \emph{remote object},
it has methods that mirror the \emph{remote object}'s methods.
From the programmer's perspective, 
\emph{stub}s are just like ordinary local objects.
When calling a \emph{stub}'s method, the underlying
RPC framework code sends messages to the \emph{remote object}'s process
to invoke the corresponding method there.
For a given object, the process that creates that object is referred
as \emph{host} of that object,
the process that holds a \emph{stub} representing 
that object is called \emph{client},
the \emph{host} is also called \emph{server} to that \emph{client} process.
In \js{}, since functions are first class citizens, it is possible
to pass a function as a parameter or return a function as a result.
Nodermi treats functions and objects alike : functions could also be 
\emph{remotely referenced}.

\nodermiexamplefig{}

Nodermi encapsulates inter-process communication via \emph{stub}s.
In the course of remote method invocations
nodermi automatically 
create \emph{stub}s for the argument objects on the server process.
In essential it preserves the single address space illusion on the
server process as well,
the server process could invoke methods of the parameter objects
as if they are in the same address space.
Figure~\ref{fig:nodermiexample} shows a
seamless execution of \emph{Process A}
calls a remote method \emph{method1} on \emph{Process B} which
will call \emph{callbackA} on  \emph{Process A} provided
as a parameter in the original remote method invocation.
A \emph{stub} pointing to \emph{callbackA} is created automatically
on \emph{Process B}.
It makes no difference for the code that if \emph{stubB} and \emph{callback}
are ordinary local objects or not.
Using nodermi, 
the structure of our original object-oriented code base could be preserved.
A process only need to explicitly register a few entry point objects to nodermi 
so other processes could get initial \emph{stub}s.
In our system, the master registers its application management object in nodermi.
A worker would first get \emph{stub} of the master's application management object.
Then the worker could register its application instance to master 
via a method call on the \emph{stub}.
On the master side, a \emph{stub} to the application instance is created and
stored in the master's application instance table.
The worker could also obtain \emph{stub}s to application instances on other workers by 
calling a method on the its \emph{stub} to master's application management object.
The worker could then directly communicate to other workers
by calling methods on the newly created \emph{stub}s 
even it does not have other workers' addresses in configuration.


\section{Semantics}

Unlike traditional RPC frameworks where the process halts for the
completion of remote method execution~\cite{birrell1984implementing},
nodermi is fully asynchronous because \nodejs
is single threaded and event based.
In nodermi a remote method call returns immediately
like any other IO related asynchronous methods.
Thus the \emph{return} value is not defined for remote method calls.
If the method itself is already asynchronous, 
nodermi fully preserves the semantics of the original method design,
because the callbacks provided by the caller could
be called on the remote side as shown in Figure~\ref{fig:nodermiexample}.
If the method is originally synchronous,
it needs to be modified to take an optional callback function
if caller wants to ``wait'' for the completion of this method.
Luckily, it is not hard to make such changes and methods involves
IO are already asynchronous.

For the same reason,
changes made to the properties of a stub have no effect on the remote object.
Vice versa, the server's update to the properties of a local object will 
not be synchronized to its stubs either.
In essence,
the stub's properties are merely a snapshot of the state of 
the remote object right before the stub is created.
In \js{}, reading or writing properties is synchronous.
Although we can intercept writing existing properties using
\emph{setter} and propagate the writings to other processes,
we still cannot preserve the semantics of the local property setting
where the change takes effect instantly. 
Moreover, there is no way in \js{} to intercept the operation of adding a new property or delete
a property, 
thus propagating addition and deletion of properties is unrealistic.

Unlike some RPC systems~\cite{birrell1993distributed} 
where stubs only contains methods and the properties of the remote
objects could only be accessed via stub methods,
nodermi stubs contain full object graphs mirroring the objects they represent.
The method only design puts great limitations on the
application layer and it introduces more network round trips.
Especially in \js{} applications, where 
 it is common practice to call a method with
a container object that wraps simple value parameters and callback parameters,
the method would read parameters from the container object and invoke callback
extracted from the container object.
If the stubs contain only methods, 
we would need to define several getter methods 
for these container objects, 
then replace the code that reading properties of the container object
 with several asynchronous getter method calls.
It would greatly complicate the control flow
not to mention the performance penalty.


\section{Design}

\nodermifig{}

Figure~\ref{fig:nodermi} is a diagram of nodermi's design.
A stub is created with every method pointing to the 
remote method invocation code in nodermi.
When a method of a stub is called,
nodermi encodes the parameters and some information of this method 
into a method invocation message.
The transportation layer then converts the message into 
a binary format and sends to the host of the stub's remote object.
On the server side, the transportation layer first reads 
the message from the network and invoke \emph{method invocation handler}.
The handler finds the local object which the \emph{stub}
represents,
finds the local object's method which this invocation is about,
decodes the message to reconstruct the parameters of this method call,
then call the method with the decoded parameters.


Nodermi uses TCP sockets to implement inter-process communication,
so each process needs to assign host and port for nodermi.
Since each process would have a different host port pair for nodermi,
nodermi uses these host port pairs as process identifiers.
Nodermi also assigns a unique id for every local object it has processed.
A stub stores its remote object's id and process identifier of its remote object's host.
That's how nodermi could find host processes for remote objects and
find the local objects for remote method invocation.

To get a initial \emph{stub}, a process 
calls \emph{retrieveObj} API with a remote process's identifier and 
an object name.
The remote process needs first register a local object with that name by
\emph{registerObj} API.
Programmers need to explicitly calling nodermi for the initial \emph{stub}s,
nodermi will automatically create new \emph{stub}s for method parameters.


We create a separate layer for transportation component to decouple network
IO from other nodermi logic.
The transportation component serialize and de-serialize message objects
and manages network communications.
Right now we use data exchange protocol ProtoBuf~\cite{protobuf} to convert message objects to binary
formats and send the binary data on long running TCP connections.

Let's explain the message flow with the example 
in Figure~\ref{fig:nodermiexample}.
As shown in the code snippet on the top left of the figure,
process A invokes \emph{method1} with a parameter a function named \emph{callbackA}.
First nodermi creates a method invocation message
contains information about the remote method being called:
the ids of \emph{method1} and \emph{objB}.
The message also contains information about the parameters:
the id of \emph{callbackA} and the type of \emph{callbackA} is a function.
After process B receives the message,
it reconstructs the parameters for the method call,
that is creating a stub for \emph{callbackA},
the stub is a function like the original \emph{callbackA} and 
stores \emph{callbackA}'s id and Process A's process identifier,
we denote this stub as \emph{stubCallbackA}.
Then process B finds \emph{objB} and \emph{method1} by the ids in the message.
After that,
process B invokes the \emph{method1} with \emph{stubCallbackA} as parameter.
The \emph{method1} then invokes \emph{stubCallbackA} with \emph{result}.
Finally, \emph{callbackA} is invoked
via a remote method call by process B,
and the result computed in process B is printed in process A.
% Notice that the variable \emph{result} is not necessary B's local object,
% it could be a stub reference to an object


\section{Encode and Decode}
As we mentioned earlier, nodermi assigns ids for local
objects that are referenced remotely.
An object id is written to the object in a hidden field
so an object's id remains the same throughout the lifetime of the process.
When creating a stub,
the host process's identifier as long as the remote object's id
are written in hidden fields of the stub.
To avoid conflict with user defined fields, these hidden fields are prefixed
with ``\_\_r'' and they are not enumerable or modifiable.

By default nodermi encodes the whole object graph of an object recursively.
Each property of an object is encoded 
as an object descriptor with its property name.
An object descriptor contains an object's id, its process descriptor,
its type and a list containing its encoded properties.
Cyclic reference is handled by encoding cyclic reference as
special placeholder objects with no properties.
To avoid encoding unnecessary information,
nodermi assumes properties with ``\_'' prefixed names are private
 and omit them during encoding.
Nodermi also allows programmers to explicitly 
inform the encoder to include or skip 
an object's certain properties
by setting some predefined fields of that object.

The decoder reconstruct parameters based on the information 
provided by the client's encoder.
When creating a stub object,
all the properties of its remote object specified in the message 
are decoded recursively.
Simple properties like numbers or strings are directly set in the stub.
For methods and object property, new stubs are created accordingly.

% better connection here
Nodermi adopts several policies to minimize the size of messages:
When encoding objects of type Error, Date and Buffer,
only the value of these objects are encoded,
and they are decoded as new local objects instead of stubs,
because it makes little sense to invoke remote method call for these objects.
When encoding a stub that references an object from the receiver,
the properties are omitted, only object id and a type string indicating 
it is from the receiver are encoded,
the receiver would decode this object as the original local object.
Objects of Socket type are discarded entirely, because
there is little reason that a socket should be exposed as a remote object.
Methods that has no practical value of being called remotely are
omitted, like ``toLocaleString'' and ``toJSON''.
In the future, 
we could further improve the encoder's efficiency 
by applying these policies to more objects and methods.


\section{Distributed Garbage Collection}
\js{} relies on garbage collection to reclaim memory taken by
objects that are not referenced anymore in the program.
However, the garbage collector is not aware a local object
could also be referenced by another process through nodermi.
In the example shown in Figure~\ref{fig:nodermiexample},
after \emph{method1} of \emph{stubB} is called,
\emph{callbackA} is out of scope in process A,
it is not referenced anymore by the user code.
If nodermi does not hold reference to \emph{callbackA},
it could be garbage collected before it is invoked.
In fact, in practice callback functions like \emph{callbackA} are almost
immediately garbage collected because it is likely that these functions
live on the new space of a generational garbage collector heap that is frequently
garbage collected.
However, if we naively keep reference to the \emph{callbackA} in nodermi,
our application is surely prone to memory leak as objects that are once remotely
referenced
will never be garbage collected even when local or remote processes 
no longer use them.
Setting a timeout to automatically clean these objects from nodermi
 is not going to work either,
since there is no guarantee that when the client is going to use the object.
For example,
when a process registers a listener function to a remote event publisher,
the listener could be remotely called at anytime in the future.


There are a lot of research related to garbage collection in a distributed
environment~\cite{abdullahi1998garbage}, ~\cite{birrell1993distributed}.
We designed a mechanism that is similar to the sequence reference counting algorithm
of Birrell et al.~\cite{birrell1993distributed}.
We will discuss the difference between our work and ~\cite{birrell1993distributed}
in section~\ref{sec:relatedrpc}.

The high level design of our distributed garbage collecting 
algorithm works as follows.
For each process, nodermi has an object map containing the objects 
that are still remotely referenced.
The object map prevents garbage collector from prematurely garbage collecting
these objects by creating references to them.
This map is also necessary for looking up local objects 
when handling \emph{method invocation} messages.
An object is removed from the map once its stubs
are no longer needed by clients.
Intuitively,
when a stub is no longer needed by a client,
the stub is good to be garbage collected by the client process.
Nodermi creates weak references(implemented by node-weak~\cite{nodeweak}) 
to the \emph{stub}s it creates
and hands regular references to the upper layer code.
Weak reference will not keep the underlying object alive
if the object is only referenced by weak references.
So when a \emph{stub} is not used anymore,
it would be garbage collected,
then a callback function that we registered when creating the weak
reference will be fired,
we use the callback function to send 
a dereference message to notify the server
a remote reference is now removed.


\nodrmiobjmapfig{}

Figure~\ref{fig:nodermiobjmap} shows the structure of
the object map and the stub map where nodermi stores weak references to stubs.
The object map contains the local objects and information of
their remote references.
A remote reference is represented by a session id,
a unique id generated by nodermi every time it invokes encoder.
When a local object is encoded, the current session id is added to 
the object map.
On the client side, the session id is stored in the stub for that object.
When a \emph{stub} is garbage collected,
a dereference message with the object id and session id will 
be sent to the server side.


\nodrmiracefig{}

% using reference counter is useless because process A only
% has one reference to stubB even objB is sent multiple times

It is notable that 
unlike RPC systems 
where only one \emph{stub} is created for one object per client,
nodermi creates a new \emph{stub} for a remote object every time
the process obtains a new reference to that object.
We use this design because it
greatly simplifies the implementation of nodermi decoder and
the communication between processes.
Let's assume we create one \emph{stub} for one object per client.
Consider the case in Figure~\ref{fig:nodermirace},
Process A reference remote object \emph{objB} twice,
the host Process B receives a dereference message
after it sends out the second reference to \emph{objB},
so \emph{objB} could be garbage collected even process A still holds a remote
reference.
One way of fixing this is that
the client needs to send a message to the host before creating the \emph{stub},
and the server makes sure the remote object's reference record contains the client.
In this case, the client should create only one \emph{stub} per remote object,
so the client needs proper synchronization between invocation of decoders to
avoid creating duplicate \emph{stub}s. This is basically the implementation
of ~\cite{birrell1993distributed}. %TODO


So far, we only considered the scenario that a process sending its local
objects to another process.
It is also possible that a process would send a \emph{stub} to another process.
If the \emph{stub}'s host is receiver, than there is no problem because no remote
reference is created.
If the \emph{stub}'s host is not receiver(it could not be the sender either),
then 
a reference record needs to be added to the host's object map.
In this situation,
the sender process will first send a reference message to 
ask the host
to generate a new session id for a new remote reference
and put that session id into the host's object map,
after that, 
the sender will encode the \emph{stub} with the new session id
and send to the receiver.
When the receiver receives the message and
creates a new \emph{stub} to the original object on host,
the host already has the record of this new remote reference.


Nodermi also remove a remote process's references to local objects if
it detects that remote process is terminated.
Nodermi keeps a table of last response time of remote processes it contacted,
it updates the table every time it receives a request or a response from a remote 
process. 
When the table entry for a process is not updated for more than 60 seconds, nodermi
will send a ping message to that process.
If the ping message is unanswered, all references by that process will be removed
from the object map.
This strategy ensures that a terminated process will not cause memory leak on
other processes.




% FIXME comparison

% semantics of properties, methods, this  field accesses, object identity
% caja, druby, javascript , python

% \section{Issues}

% async
% network partition, transmission failure, server restart