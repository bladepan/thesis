\chapter{nodermi: A Remote Procedure Call Framework for \nodejs{}}
\label{ch:rmi}
\markright{nodermi}
In the single process version of \cb,
everything lives in the same address space,
which allows application code to invoke system components' functionality.
As \cbtwo divides \cb into multiple processes,
some of those local method invocations need to be replaced by
inter-process communication,
because as the framework spreads its state
and responsibility to multiple processes,
an operation initiated in one process
could require access to state located in another process.
For example,
in the single process version,
closing a virtual browser
is implemented by invoking the \code{close} method of the virtual browser
object.
If the virtual browser is in another process, closing it requires that a request be sent to that process.
We could have introduced new objects and methods to send specific messages,
but this approach is undesirable for the following reasons.
First, there are many call sites that would need to be changed.
Second, we would also have to design message formats for many different methods and
write handler code to parse and process each of these messages.
Third, since our codebase is continuously evolving, any changes to existing methods
would require modifications to the message communication layer.

To avoid having to manually create and maintain messaging code for each
method, we developed nodermi~\cite{nodermi}, an object-oriented
remote procedure call (RPC) framework for \nodejs{}.
% Nodermi hides the complexity of inter-process communication details from
% upper layer code and is adaptive to code changes.

Before we discuss the implementation of nodermi,
we first introduce some terms for nodermi and
RPC systems in general.
We use the term \emph{local object}
to refer to objects that are local to a calling process.
We use the term \emph{remote object} to represent objects that are
located in processes other than the calling process.
We use \emph{stub} or \emph{remote reference} to refer to special objects created
by nodermi that represents \emph{remote object}s in the calling process
(we can think of \emph{stub}s as proxies to remote objects).
We say an object is \emph{remotely referenced} from a process
if there are \emph{stub}s representing it.
Each \emph{stub} represents one \emph{remote object} and
it has methods that mirror the \emph{remote object}'s methods.
From the programmer's perspective,
\emph{stub}s appear like ordinary local objects.
When calling a \emph{stub}'s method, the underlying
RPC framework code sends messages to the \emph{remote object}'s process
to invoke the corresponding method there.
For a given stub,
the object it represents is called its \emph{source object},
the process that creates the \emph{source object}
is referred to as the \emph{host} of the stub. 
The \emph{host} process takes on the role of a \emph{server}, 
whereas the process that holds a \emph{stub} to the object act as a \emph{client}.
In \js{}, since functions are first class citizens, it is possible
to pass a function as an argument or return a function as a result.
Nodermi treats functions and objects alike so that functions can also be
referred to remotely.

\section{Semantics}
\label{sec:semantics}

\nodermiexamplefig{}

\paragraph{Synchronous Methods}
Unlike RPC frameworks in which a calling process blocks during the
completion of the remote method~\cite{birrell1984implementing},
nodermi is fully asynchronous since \js{} functions must not block.
In nodermi a remote method call returns immediately after initiating the communication,
similar to other IO-related asynchronous methods.
Thus the method's return value is not available when the stub method returns on the client.
To obtain the result of a remote method invocation,
the remote method must be implemented asynchronously,
passing its result(s) to the caller via a callback function.
If a caller requires the knowledge that a method has completed - with or without
returning a result, the method must be written in an asynchronous style.
Thus, some existing methods will need to be changed to be able to invoke them 
remotely via nodermi.

\nodermipassbyreffig{}


\nodrmipassbyvalfig{}


\paragraph{Passing Arguments}
Nodermi copies most arguments by value, including built-in primitive types
and objects.  If an object refers to other objects, these objects are copied 
as well, so that an object's entire transitive closure is copied.
Since JavaScript functions contain closure, it is not possible to copy them.
Instead, we create stubs for functions and methods before passing them
to the remote object's method.  If a method needs to invoke 
methods on objects passed as arguments, then such invocations
will cause the created stubs to initiate a remote method
call to the original object.  The client must create handlers
to receive and process these remote method invocations.
For instance, in Figure~\ref{fig:nodermiexample}, 
when \emph{Process B} calls the remote method \emph{method1}
in \emph{Process A} with a function argument,
a stub for the argument
\emph{callbackA} is created in \emph{Process A} because
it is not possible to copy function \emph{callbackA} to \emph{Process B}.
The stub to \emph{callbackA} is passed as an argument to
 \emph{method1}.
Then \emph{method1} invokes the stub to \emph{callbackA} as if it is a ordinary
 local function and the actual \emph{callbackA} is invoked in \emph{Process A}. 


For certain built-in types, e.g. \code{Date}, \code{Error}, \code{Buffer}, 
we copy their contents and recreate them via their constructors.
So the a method could call methods of these objects without 
remote method invocation.
In this case, no stubs is created as emphasized in Figure~\ref{fig:nodermipassbyval}.
Besides built-in types, nodermi also allows programmers to
register customized types to be copied and recreated via constructors.
The objects of these customized types need to implement a method to dump
their contents as constructor arguments.
This semantic is unlike Java RMI\cite{j2eedoc}, which loads
object's methods through a separate mechanism via Class Loaders,
we assume constructors of these objects are registered in
both sender process and receiver process.

Nodermi allows programmers pass stubs as arguments.
If we treat a stub like other normal objects and create a remote reference 
 for the stub when it is passed to a remote method. 
Then when calling a method of the newly created remote reference,
a remote method invocation will be initiated to call the corresponding method
of the stub, which will in turn initiate another remote method invocation
to call the object the stub represents.
The chain of remote method invocation initiated by a method call could
be arbitrary long.
To avoid this problem, when we pass a stub to a remote method call,
we create a new remote reference referencing 
 the stub's \emph{source object} instead of referencing the stub itself
 (See Figure~\ref{fig:nodermipassbyref}).
Then calling method on the new remote reference will initiate 
communication directly to the stub's host process.
An exception is that when the stub's host process is the server
process of the original remote method that we are passing arguments to,
it would be unnecessary to create a remote reference 
in the server process to reference one of its local object,
we use the stub's source object directly instead of 
creating a new remote reference.


\paragraph{Stub Property}
A stub's properties is a snapshot of the properties
of its source object.
We could read or write properties of a stub directly.
But the changes we made to a stub's property
will not be synchronized to its source object.
Vice versa,
changing the properties on the source object has no effect
on the stub either.
It is ideal to make the stub acts like a regular reference
to its source object such that
changes made on one side would be reflected on the other.
It is not feasible to implement this semantics because
in \js{} reading or assigning a object property is synchronous,
we cannot block to wait for synchronization takes effect
 during these operations.
We could have intercept assignment to existing properties using
\emph{setter} and propagate the assignment to other processes.
We still cannot preserve the semantics of the local property assignment
where the property update takes effect right after the assignment statement returns.
Moreover, there is no way in \js{} to intercept the operation of
adding a new property or deleting a property.

% TODO comparison...

\section{Design}

\nodermifig{}

As shown in Figure~\ref{fig:nodermi},
calling a stub method results in calling
\emph{remote method invocation} module in nodermi.
This module
first encodes the arguments of the method call
 and other necessary information
as a \emph{method invocation message}.
The transport layer then converts the message to
a binary string and sends it
to the server process of the remote method.
On the server side, the transport layer reads
the message from the network and invokes \emph{method invocation handler}.
The handler reads the description of the arguments 
 by decoding the \emph{method invocation message}.
Then it recreates the arguments according to 
the semantics of argument passing (see section~\ref{sec:semantics}).
Finally, the handler invokes the corresponding local method with the arguments
it constructs earlier.

To locate the host process and source object of a stub,
nodermi stores the host process's identifier and the source object's object id
inside the stub so these information could be retrieved later by 
the \emph{remote method invocation} module.
The process identifier is a host and port pair that each process
allocates for nodermi to listen incoming TCP message.
The object id is a unique id nodermi assigns for each object that
is remotely referenced.


Let's explain the message flow with the example
in Figure~\ref{fig:nodermiexample}.
As shown in the code snippet on the top left of the figure,
process A invokes \emph{method1} with a function argument \emph{callbackA}.
First nodermi creates a \emph{method invocation message}
contains the object id of \emph{objB} and the method being called.
The message also contains a description of the arguments:
the object id of \emph{callbackA} and
the type of \emph{callbackA}.
After process B receives the message,
it reconstructs the arguments for the method call:
creating stub \emph{stubCallbackA} for \emph{callbackA} since it is a function.
The stub \emph{stubCallbackA} is a function and
it stores \emph{callbackA}'s id and Process A's process identifier.
After process B finds \emph{objB} via object id,
process B invokes \emph{method1} with \emph{stubCallbackA} as argument.
Then the \emph{method1} then invokes \emph{stubCallbackA} with \emph{result}
which in turn initiate a remote method invocation to call \emph{callbackA} in process A.


\paragraph{Bootstrap}
It is clear that nodermi automatically creates stubs during
passing arguments in remote method invocation without programmers
explicitly calling framework API.
However, the first \emph{stub} cannot be obtained
via remote method invocation.
To bootstrap the RPC communication,
nodermi provides \code{registerObj} method
to register a local object with a name
and \code{retrieveObj} method to 
directly create a stub representing
a remote object that has been registered via
\code{registerObj}.

\paragraph{Message Encoding}
When passing an object from a process to another,
nodermi adopts several policies to minimize the size of messages:
Nodermi assumes properties whose names starts with ``_'' are private properties
and skip them during encoding;
Nodermi skips certain types of objects e.g. Sockets because
it makes no sense for these objects to be read remotely;
Nodermi also provides mechanism for programmers to specify which
properties could be ignored during encoding;
Finally, nodermi use Protobuf~\cite{protobuf} a very compact binary format 
to serialize its messages.


\section{Distributed Garbage Collection}
\js{} relies on garbage collection to reclaim memory taken by
objects that are not referenced in the program.
However, the garbage collector is not aware a local object
could be referenced by another process through nodermi.
In the example shown in Figure~\ref{fig:nodermiexample},
after \emph{method1} of \emph{stubB} is called,
\emph{callbackA} is out of scope in process A,
it is not referenced anymore by the user code.
If nodermi does not hold reference to \emph{callbackA},
it could be garbage collected before it is invoked.
In fact, in practice callback functions like \emph{callbackA} are almost
immediately garbage collected because it is likely that these functions
live on the new space of a generational garbage collector heap that is frequently
garbage collected.
However, if we naively keep reference to objects like
 \emph{callbackA} in nodermi,
our application is surely prone to memory leak
as objects that are once remotely referenced
will never be garbage collected even after the local and remote processes
no longer use them.
Setting a timeout to automatically clean references of
these objects from nodermi is not going to work either,
since there is no guarantee that when the client is going to use a
particular object.
For example,
when a process registers a listener function to a remote event publisher,
the listener could be remotely triggered at anytime in the future.


There are a lot of research related to garbage collection in a distributed
environment~\cite{abdullahi1998garbage}, ~\cite{birrell1993distributed}.
We designed a mechanism that is similar to the sequence reference counting algorithm
designed by Birrell et al.~\cite{birrell1993distributed}.
We will discuss the difference between our work and ~\cite{birrell1993distributed}
in section~\ref{sec:relatedrpc}.

The high level design of our distributed garbage collecting
algorithm works as follows.
For each process, nodermi has an object map containing the objects
that are still remotely referenced.
The object map prevents garbage collector from prematurely garbage collecting
these objects by holding references to them.
This map is also necessary for looking up local objects
when handling \emph{method invocation} messages.
On the other hand, nodermi holds weak references(implemented using node-weak~\cite{nodeweak})
to \emph{stub}s.
Garbage collector could collect objects that are only
referenced by weak references.
When a stub is not used, it would be garbage collected,
then a callback function which is registered when creating
the stub's weak reference is fired to
send the stub's host process a \emph{dereference message}.
Upon receiving a dereference message,
nodermi knows that a remote reference to a local object
is now defunct.
In this way, an object could be removed from the object map after
all of the stubs representing it being garbage collected.
At this point, if it is not referenced locally it could
be safely garbage collected.


\nodermiobjmapfig{}

Figure~\ref{fig:nodermiobjmap} shows the structure of
the object map and the stub map
where nodermi stores weak references to stubs.
The object map contains the local objects and information of
their remote references.
A remote reference is represented by a session id,
a unique id generated by nodermi every time it transmits objects
to remote processes.
When a local object is transmitted, the current session id is added to
the object map indicating a new remote reference is created.
On the receiving side, the session id is written to
the \emph{stub}s created in this transmission.
When a \emph{stub} is garbage collected,
the \emph{dereference message} will contain
the remote object's id and the session id stored
in the stub.


So far, we only considered the scenario of a process sending its local
objects to another process.
It is also possible that a process could send a \emph{stub} to another process.
If the \emph{stub}'s host is the receiver, then there is no problem because no remote
reference is created.
If the \emph{stub}'s host is not the receiver(it could not be the sender either),
then a record needs to be added to the host's object map to indicate
a new remote reference.
In this situation,
the sender process first sends a \emph{reference message} to
ask the host
to generate a new session id
and put that session id into the host's object map.
After that,
the sender will send the \emph{stub} and the new session id
to the receiver.
By the time the receiver gets the message from the sender
and
creates a new \emph{stub} to the original object,
the host already has the record of this new remote reference.

A process could terminate without explicitly releasing its remote references
by sending dereference messages.
This could create false remote references on other processes.
To remove these false remote references,
nodermi cleans a remote process's records in the object map if
it detects that remote process is terminated.
Nodermi keeps a table of last response time of remote processes it contacted,
it updates the table every time it receives a message from a remote process.
When the table entry for a process is not updated for more than 60 seconds, nodermi
will send a ping message to that process.
If the ping message is unanswered, all records of that process will be removed
from the object map.
This feature ensures that a terminated process will not cause memory leak on
other processes.




% FIXME comparison

% semantics of properties, methods, this  field accesses, object identity
% caja, druby, javascript , python

% \section{Issues}

% async
% network partition, transmission failure, server restart
