\chapter{Related Work}
\markright{Related Work}

Our work on \cb bears a relationship to several related works
which this chapter discusses, which include remote procedure call frameworks 
related to nodermi, as well as web frameworks and thin-client systems
that share similar features or goals with \cb.

\section{Remote Procedure Call Frameworks}
\label{sec:relatedrpc}

In this section we discuss RPC frameworks that present remote method
invocations, particularly those that do so using an object-oriented style.  
We are interested in how these
frameworks abstract the remote method invocations, the effort that these
frameworks require developers to make, and their special features and
drawbacks.

Dnode~\cite{dnode} is a RPC framework for \nodejs{}.  Like in nodermi, remote
method invocation is asynchronous and remote references are created automatically
as a result of remote method calls. However, dnode does not distinguish remote
references from local objects when passing them as arguments of remote
methods. As a consequence, dnode may create a remote reference representing
another remote reference, causing remote method calls to result in long chains
of inter-process communications (i.e., the ``zig-zag'' problem discussed in
Section~\ref{sec:semantics}). 


% Although this design introduces extra network
% round trips, it simplifies the distributed garbage collection implementation.
% Dnode keeps reference to the object in a reference map when the object  is
% remotely referenced. When a remote reference is garbage collected,  a
% \code{cull} message (similar to the release message in nodermi)  is sent to inform
% the remote reference's host   to remove the original object from its reference
% map.

 
Pyro~\cite{pyro} is an object-oriented RPC framework for the Python programming
language. Unlike nodermi and dnode, Pyro synchronizes  property modifications
between remote references and their source objects. This makes remote
references act more like regular references.  But if used unwisely, remote
property access can slow down the program. There are two major drawbacks for
pyro : First, pyro does not automatically create remote references for objects
passed to remote methods, programmers need to manually register these objects.
If an object is not registered, it is recreated as a \code{dict} structure (a
hash map equivalent data structure in Python) in the remote process, which discards
all of its methods. Since remote method calls look like local method calls, it is
tricky for the programmers to identify whether an object needs to be
registered or not.  Second, pyro lacks a garbage collection mechanism, 
as a result, objects passed to remote methods are kept alive as long the 
service is running.

Druby(drb)~\cite{druby} is an object oriented RPC framework that is part of Ruby's standard
library. Like pyro, it is the programmer's responsibility to explicitly tell
the framework that an object needs to be passed as a remote reference. It also
requires users to retain references to objects that are remotely
referenced  to prevent these objects from being prematurely garbage collected.
By contrast, nodermi automatically creates remote references and
takes care of distributed garbage collection.

Network objects~\cite{birrell1993distributed} is a distributed programming
paradigm that provides RPC in an object-oriented style. Java RMI~\cite{j2eedoc}
is an object-oriented RPC framework for the Java programming language. Unlike the
RPC frameworks discussed before, these two are designed for use with a statically typed language.
Both require that programmers implement classes that inherit from some
predefined interfaces in order to pass their objects by reference to remote processes.
Nodermi, on the other hand, automatically infers whether an object needs to be 
passed by reference.  The remote references in these systems do not
have properties, so the properties of a remote object could only be accessed
via remote method calls. In nodermi, 
although remote object's properties are only snapshots of the original properties, 
they can be read directly.

% They all have sophisticated distributed garbage collected
% mechanisms and they create remote references automatically.

Pyro, druby, network objects and Java RMI all default to synchronous
APIs for I/O and communication.  Likewise, in these frameworks, remote method invocations 
block until the remote processes completes the execution of the original methods.


CORBA~\cite{vinoski1997corba} is a RPC standard that facilitates implementation
of cross-platform RPC systems. CORBA requires programmers to specify  the
remote object's interface using an interface description language (IDL) and 
provide IDL bindings for the implementation language, which is commonly generated 
by tool (IDL compiler). Nodermi generates remote stubs dynamically without IDL.

\section{Web Frameworks}

% Ruby on Rails

% There are many web frameworks designed to simplify the development of web applications.
% Some web frameworks such as django focus on simplifying backend
% development by providing solutions like
% database integration, HTTP session management, mapping 
% requests to service methods, etc.
% To develop rich AJAX applications using these framework,
% the developers need to implement the server-client
% communication manually.
% We do not discuss these frameworks because they present the very problem \cb is
% trying to solve.

There is a large number of web frameworks that are designed to simplify
the development of web applications.  We select a few web frameworks that
are particularly related to \cb in the way that they provide programming
models other than the request/response programming paradigm used in
traditional web frameworks.  Following~\cite{ChenCheng:book2007}, we
categorize web frameworks that keep representation state on the server
as server-centric frameworks and web frameworks in which the server side
is not aware of representation state as client-centric.

%
%
\subsection{Server-centric Web Frameworks}


ZK~\cite{ChenCheng:book2007} is a Java-based server-centric web framework that
is in wide use. ZK applications are constructed using components, which are
represented using the ZK User Interface Markup Language (ZUML).  ZUML
components are translated into HTML and CSS when a page is rendered. A client-side 
library handles synchronization between the client's  view of and
interaction with components and their server-side  representation.  ZK does
not maintain a representation of the server document across page reloads,
which means that all presentation state must be tied to session or persistent
state. To scale ZK to multiple processes or servers, this session state must
be replicated across servers using application servers' session replicate
support  (discussed in Section~\ref{sec:sessionmanage}) which broadcast
changes to session to all the servers.

Unlike \projectname{}, ZK aims to support layout attributes, but
we have found that the complexity of its client engine leads to 
numerous layout and compatibility bugs developers must work around,
particularly when the server-side document and the client-side
document are not identical.  By contrast, \cb uses identical, HTML-based
documents on the client and the server.

ItsNat~\cite{JoseMariaArranzSantamariaItsNat} is a Java-based AJAX
component framework similar to ZK, although it uses HTML instead of
ZUML to express server documents, along with the Java W3C implementation.  
Unlike \projectname, it also does not maintain the server document 
state across visits, and cannot make use of existing JavaScript libraries.

JavaServer Faces (JSF) is a component-based web framework that is part of
the Java Enterprise Edition Platform~\cite{j2eedoc}.
Developers use XML to define application views and the framework abstracts
away server-client communication using actions and action listeners.
Although application developers do not need to know \js, component
developers need to use \js to write interactive AJAX components.
To create customized user interfaces that override the
default behaviors of existing components,
developers do need to understand \js, CSS, and HTML as well as have
JSF-specific knowledge about the request processing life-cycle, 
the details of component rendering, and others.

% Fiz~\cite{OusterhoutFiz2009} is a server centric component based web framework

% http://itsnat.sourceforge.net/index.php?_page=overview

% http://books.zkoss.org/wiki/ZK_Developer%27s_Reference/Clustering
% http://www.javaworld.com/article/2075019/jndi/j2ee-clustering--part-1.html

% http://books.zkoss.org/wiki/Small_Talks/2007/April/How_to_Run_ZK_on_Apache_%2B_Tomcat_clustering,_Part_I
% session replication "replication costly while cluster nodes more then three (it's about math, think about fully connected graph K3~K4"
% TODO every node pick an arbitrary node to replicate is also an option, wonder why they do not use this option

\subsection{Client-centric Web Frameworks}

Google Web Toolkit~\cite{GWT} allows the implementation of
AJAX applications in Java that are compiled to JavaScript (or other
targets).  Like \projectname, it provides an environment similar to 
that provided by desktop libraries, but focuses on the client-side only; 
communication with the server is outside its scope.

% Traditional AJAX programming model in which developers manage user interface use
% client side \js libraries like jQuery, angular, etc. and the client side communicate the server
% via application specific HTTP protocols
% can be categorized as client-centric.
% These models present the problems we try to solve in \cb.


A closely related project that pursues similar goals in simplifying the development
of rich web applications is Meteor~\cite{meteor}, a full stack platform for building 
web and mobile applications.  Meteor provides mechanisms that tie a client's presentation
state directly to model state that is kept in a server-side database, which in turn is 
partially replicated on the client.  As such, user input can be handled, optimistically, before 
the server roundtrip has completed. If an update is rejected by the server, the optimistic 
application is undone. 
Asynchronous updates to model data is pushed to clients.
Like other client-centric frameworks, no presentation state is kept on
the server. 

Meteor will have lower server-side cost, and thus higher scalability, than \cb, as well
as the ability to reduce user-perceived latency because of its optimistic processing.
However, we believe that this comes at a high price of complexity and increased risk.
For instance, programmers must be extremely careful to not leak sensitive data to the 
client, and they may easily expose (unintentionally) sensitive business logic to the client.  
Meteor also does not focus on the problem of simplifying the retention of presentation
state across visits, either making that state ephemeral, or requiring the programmer
use session state or store all necessary model variables in the database.

Moreover, because Meteor is integrated with its template engine, it does not play well
with third party \js libraries. This situation is getting better as more and more third
party libraries get official integration support from Meteor and unofficial integration
solutions from the community.


\section{Thin-client Systems}

Our system shares ideas with traditional thin-client and remote display 
systems such as VNC~\cite{richardson1998virtual}, Windows remote desktop, 
Citrix XenDesktop, and 
``dumb terminals'' based on the X Window  System~\cite{ScheiflerGettys:acmtg1986}.  
We note that VMWare's Horizon product provides
a way to see the user interface of actual virtual machines via a browser, with its
BLAST protocol.  Compared to these systems, \cb{} is 
unique in that it uses a markup document and differential update to it to 
describe the structure and evolution of the user interface that is rendered 
to the user.  

Mosh~\cite{winstein2012mosh} is a remote terminal application  that
synchronizes client screen states with server side terminal emulators.
Because terminal emulators are text based, the cost of maintaining screen
states is not significant. Mosh is able to provide prompt feedbacks to users
in spite of network latency by guessing the effects of users' keystrokes and
applying the guessed effects on users' screens immediately. Unlike \cb which
preserves the entire user interface state of an applications, Mosh only keeps the
current screen's state. Another difference
from our system is that Mosh does not support reconnecting to existing
sessions, the users are presented with a new window when they switch devices.

