\section{Evaluation}
\label{sec:eval}
We have wrote several web applications on top of \cb{} to test its
performance and scalability.
One application is click application,
it increments and prints a counter on HTML whenever the user clicks.
This application represents applications with simple user interactions and small amount of DOM elements.
Other applications are chat applications.
A user can join a chat room to chat with other people,
changes his nickname, send messages, view recent messages in the chat room.
Whenever the number of messages in a chat room reaches 100, the first 50 messages
are discarded.
The chat applications represents more sophisticated applications.
We implemented the chat applications use popular web frameworks Angular and JQuery
to assess how \cb{} performs with real world web technology stack.

\chatroomfig{}

We implemented a benchmark tool to simulate multiple users.
Each simulated user sends HTTP requests the same way as
a web browser does when an actual user is interacting with a web application.
In the benchmarks, each simulated user will wait for its action taking effect before 
sending the next one.
For example, in the click application, the client will wait for the counter
to be refreshed before clicking again.
In the chat application, the client will wait for
the chat message appearing on the chat window before sending another one.
To be efficient, the simulated user does not render the view, 
it just analyzes server's response message to see if its action has been processed by
the server.
For example, after processing a chat message, 
the chat application will create a new DIV element with the chat message content, 
the simulated user will know a chat message is processed after it received
the corresponding DOM update message.
% TBD

The \cb{} system is deployed on a server with 8 Intel 2.27GHz cores and 12G memory.
The benchmark tool is deployed on a separate machine.

\subsection{Click Application}
In this benchmark,
we allocate a separate virtual browser for each simulated user,
the simulated user will click on the page, 
then wait for the counter to be refreshed and click again.

\clickthroughput{}
\clicklatency{}

\clickwaitthroughput{}
\clickwaitlatency{}

\subsection{Chat Applications}
See Fig.\ref{fig:appinstance},
we use \appins{}s to represent application state of chat rooms.
Each \appins{} has the corresponding chat room's model object ChatRoom.
There could be multiple virtual browsers inside an \appins{} to  
serve requests from multiple users.
If \emph{userA} requests Application URL http://example.com/chat,
an \appins{} and a virtual browser is created.
Let's say the \appins{}'s id is \emph{appins1},
the virtual browser's id is \emph{vb1}.
\emph{appins1} contains an chat room's model object.
\emph{vb1} constructs initial HTML document provided by developer and 
executes application \js{} code.
Then \emph{userA} is redirected to http://example.com/chat/a/appins1/b/vb1.
Other people can join this chat room by requesting the \appins{} URL
http://example.com/chat/a/appins1.
For example, \emph{userB} requests http://example.com/chat/a/appins1,
another virtual browser \emph{vb2} is created and \emph{userB} will be
redirected to http://example.com/chat/a/appins1/b/vb2. 

In the benchmark, 
the simulated users will be grouped into groups of five.
At the beginning of the benchmark, 
for every group one user will request for Application URL to make 
\cb{} create an \appins{},
after that, the remaining users will use the \appins{} URL to start
their own session.
Thus, in the benchmark every five simulated user will share a chat room.

Each simulated user will send 300 chat messages.
Each chat message is a sentence of 15-20 characters.
The user would wait for the previous chat message appended on the chat history
panel before sending the next one.
The user would wait for 5-10 seconds before sending each message,
this is simulating the time for a human to think and type a message.

We measure the time between the moment 
the user hit the enter key to send the message to 
when the message is echoed back as latency of the chat application.


% The simulated user will perform the following actions:
% \begin{enumerate}
% \item Sleeps for 0-20 seconds. This is simulating the users enter the 
% chat room at different times.

% \item Double click the welcome panel to show the user name editing input box.

% \item Input a new name in the user name editing input box and hit enter.

% \item \label{itm:chatinput} Input a 15-20 character sentence in the chat message input box and hit enter.

% \item Sleeps for 5-10 seconds and repeat step ~\ref{itm:chatinput} 
% until the user has sent 300 messages. 
% This is simulating the time for the user to think and type a message.

% \end{enumerate}


% In section \ref{sec:angular} and \ref{sec:jquery}, 
% we will discuss the benchmark

\appinstancefig{}



\subsubsection{Angular Chat Application}
\label{sec:angular}
Angular.js~\cite{angular} is a \js{} framework that enable the developers to 
use HTML elements to declare dynamic views.
Fig.\ref{fig:angularchatlatency} shows the latency perceived by benchmark tool
at different workload.
The system can support much fewer concurrent clients than the click application.
First of all, it is a much more complex application than the click application,
the system needs more memory and CPU resource to support each user.
Second, every time the user sends a message, the view of other virtual browsers
in the same chat room needs to be updated as well.
Third, Angular.js brings a substantial overhead 
to pay for the price of friendly programming interface.

\angularchatlatency{}

\subsubsection{JQuery Chat Application}
\label{sec:jquery}
Fig.\ref{fig:jquerychatlatency} shows latency of JQuery Chat.
The JQuery Chat supports almost twice the number of users comparing to Angular Chat.


\jquerychatlatency{}